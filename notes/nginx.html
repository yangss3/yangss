<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Nginx 相关 | YangSS</title>
    <meta name="description" content="Nicholas Yang's personal blog.">
    <link rel="stylesheet" href="/yangss/assets/style.5f22726e.css">
    <link rel="modulepreload" href="/yangss/assets/Home.fccd6d51.js">
    <link rel="modulepreload" href="/yangss/assets/app.df974142.js">
    <link rel="modulepreload" href="/yangss/assets/notes_nginx.md.1ca49aba.lean.js">
    <link rel="modulepreload" href="/yangss/assets/app.df974142.js">
    <meta name="twitter:title" content="Nginx 相关 | YangSS">
    <meta property="og:title" content="Nginx 相关 | YangSS">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/yangss/" aria-label="YangSS, back to home" data-v-40587210 data-v-7ac13a1e><!----> YangSS</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/articles/" data-v-49fe041d>Articles <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item active" href="/yangss/notes/" data-v-49fe041d>Notes <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/projects" data-v-49fe041d>Projects <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--[--><div class="flex space-x-5 ml-5"><button class="icon-button" title="Bookmarks" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24"><path d="M17 18l-5-2.18L7 18V5h10m0-2H7a2 2 0 0 0-2 2v16l7-3l7 3V5a2 2 0 0 0-2-2z" fill="currentColor"></path></svg><!--]--></button><button class="icon-button" title="GitHub" data-v-5dee39e6><a href="https://github.com/yangss3" target="_blank" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24"><path fill="currentColor" d="M16.24 22a1 1 0 0 1-1-1v-2.6a2.15 2.15 0 0 0-.54-1.66a1 1 0 0 1 .61-1.67C17.75 14.78 20 14 20 9.77a4 4 0 0 0-.67-2.22a2.75 2.75 0 0 1-.41-2.06a3.71 3.71 0 0 0 0-1.41a7.65 7.65 0 0 0-2.09 1.09a1 1 0 0 1-.84.15a10.15 10.15 0 0 0-5.52 0a1 1 0 0 1-.84-.15a7.4 7.4 0 0 0-2.11-1.09a3.52 3.52 0 0 0 0 1.41a2.84 2.84 0 0 1-.43 2.08a4.07 4.07 0 0 0-.67 2.23c0 3.89 1.88 4.93 4.7 5.29a1 1 0 0 1 .82.66a1 1 0 0 1-.21 1a2.06 2.06 0 0 0-.55 1.56V21a1 1 0 0 1-2 0v-.57a6 6 0 0 1-5.27-2.09a3.9 3.9 0 0 0-1.16-.88a1 1 0 1 1 .5-1.94a4.93 4.93 0 0 1 2 1.36c1 1 2 1.88 3.9 1.52a3.89 3.89 0 0 1 .23-1.58c-2.06-.52-5-2-5-7a6 6 0 0 1 1-3.33a.85.85 0 0 0 .13-.62a5.69 5.69 0 0 1 .33-3.21a1 1 0 0 1 .63-.57c.34-.1 1.56-.3 3.87 1.2a12.16 12.16 0 0 1 5.69 0c2.31-1.5 3.53-1.31 3.86-1.2a1 1 0 0 1 .63.57a5.71 5.71 0 0 1 .33 3.22a.75.75 0 0 0 .11.57a6 6 0 0 1 1 3.34c0 5.07-2.92 6.54-5 7a4.28 4.28 0 0 1 .22 1.67V21a1 1 0 0 1-.94 1z"></path></svg><!--]--></a></button><button class="icon-button" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24" style="display:none;"><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938A7.999 7.999 0 0 0 4 12z" fill="currentColor"></path></svg><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24" style=""><path d="M12 18a6 6 0 1 1 0-12a6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636L5.636 7.05L3.515 4.93zM16.95 18.364l1.414-1.414l2.121 2.121l-1.414 1.414l-2.121-2.121zm2.121-14.85l1.414 1.415l-2.121 2.121l-1.414-1.414l2.121-2.121zM5.636 16.95l1.414 1.414l-2.121 2.121l-1.414-1.414l2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z" fill="currentColor"></path></svg><!--]--></button></div><!--]--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/articles/" data-v-49fe041d>Articles <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item active" href="/yangss/notes/" data-v-49fe041d>Notes <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/projects" data-v-49fe041d>Projects <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-17c48e2f><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/notes/git">Git 常用命令</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/notes/linux">Linux 相关</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/yangss/notes/nginx">Nginx 相关</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#centos-环境安装-nginx">CentOS 环境安装 nginx</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#安装依赖包">安装依赖包</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#安装-nginx">安装 nginx</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#常用命令">常用命令</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#web-server-configuration">Web Server Configuration</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#设置虚拟服务器（virtual-server）">设置虚拟服务器（virtual server）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#configuring-locations">Configuring Locations</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#location-priority">Location Priority</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#using-variables">Using Variables</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#returning-specific-status-codes">Returning Specific Status Codes</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#rewriting-uris-in-requests">Rewriting URIs in Requests</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#handling-errors">Handling Errors</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#serving-static-content">Serving Static Content</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#root-directory-and-index-files">Root Directory and Index Files</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#trying-several-options">Trying Several Options</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#optimizing-performance-for-serving-content">Optimizing Performance for Serving Content</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#enabling-tcp-nopush">Enabling tcp_nopush</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#nginx-reverse-proxy">NGINX Reverse Proxy</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#passing-a-request-to-a-proxied-server">Passing a Request to a Proxied Server</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#passing-request-headers">Passing Request Headers</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#configuring-buffers">Configuring Buffers</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/notes/package-json">package.json 配置说明</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/notes/pkg-manager">Package Manager</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/notes/regexp">正则表达式</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/notes/type-challenges">Type Challenges</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/notes/typescript">TypeScript 笔记</a><!----></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="nginx-相关" tabindex="-1">Nginx 相关 <a class="header-anchor" href="#nginx-相关" aria-hidden="true">#</a></h1><h2 id="centos-环境安装-nginx" tabindex="-1">CentOS 环境安装 nginx <a class="header-anchor" href="#centos-环境安装-nginx" aria-hidden="true">#</a></h2><blockquote><p>新机器推荐按<a href="http://nginx.org/en/docs/install.html" target="_blank" rel="noopener noreferrer">官网文档</a>的教程进行安装</p></blockquote><h2 id="安装依赖包" tabindex="-1">安装依赖包 <a class="header-anchor" href="#安装依赖包" aria-hidden="true">#</a></h2><p>安装 <code>gcc</code> (一般服务器镜像都已安装)</p><div class="language-"><pre><code>yum -y install gcc
</code></pre></div><p>安装 <code>pcre, zlib, openssl</code></p><div class="language-"><pre><code>yum install -y pcre pcre-devel
yum install -y zlib zlib-devel
yum install -y openssl openssl-devel
</code></pre></div><h2 id="安装-nginx" tabindex="-1">安装 nginx <a class="header-anchor" href="#安装-nginx" aria-hidden="true">#</a></h2><p>下载 nginx <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener noreferrer">安装包</a></p><div class="language-"><pre><code>wget http://nginx.org/download/nginx-1.17.8.tar.gz
</code></pre></div><p>解压到 <code>/usr/local</code> 目录下</p><div class="language-bash"><pre><code><span class="token function">tar</span> -zxv -f nginx-1.17.8.tar.gz -C /usr/local
</code></pre></div><p>进入解压后的目录</p><div class="language-bash"><pre><code><span class="token builtin class-name">cd</span> /usr/local/nginx-1.17.8

<span class="token comment"># 执行下面三个命令</span>
./configure
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span>
</code></pre></div><p>切换到 <code>/usr/local/nginx/sbin</code> 目录</p><div class="language-bash"><pre><code><span class="token builtin class-name">cd</span> /usr/local/nginx/sbin

<span class="token comment"># 启动</span>
./nginx

<span class="token comment"># 或者配置软连接</span>
<span class="token function">ln</span> -s /usr/local/nginx/sbin/nginx /usr/local/sbin
</code></pre></div><p>访问服务器 ip，查看是否启动成功</p><h2 id="常用命令" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令" aria-hidden="true">#</a></h2><div class="language-bash"><pre><code>nginx -s reload <span class="token comment"># Reload the configuration file</span>
nginx -s quit <span class="token comment"># Shut down gracefully</span>
nginx -s stop <span class="token comment"># Shut down immediately (fast shutdown)</span>
nginx -s reopen <span class="token comment"># Reopen log files</span>
</code></pre></div><h2 id="web-server-configuration" tabindex="-1">Web Server Configuration <a class="header-anchor" href="#web-server-configuration" aria-hidden="true">#</a></h2><h3 id="设置虚拟服务器（virtual-server）" tabindex="-1">设置虚拟服务器（virtual server） <a class="header-anchor" href="#设置虚拟服务器（virtual-server）" aria-hidden="true">#</a></h3><p>在 <code>http</code> 上下文中，通过 <code>server</code> 指令来定义一个虚拟服务器</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># Server configuration</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也可以添加多个 <code>server</code> 块来定义多个虚拟服务器。</p><p><code>server</code> 配置块通常包含一个 <code>listen</code> 指令来指定服务器要监听的客户端请求的 IP 地址和端口。支持 IPv4 和 IPv6 地址，且需要将 IPv6 地址放在方括号中。</p><p>例如一个监听 IP 地址为 127.0.0.1， 端口为 8080 的服务器配置块：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span> 127.0.0.1:8080</span><span class="token punctuation">;</span>
  <span class="token comment"># Additional server configuration</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果省略端口，则使用标准端口。 同样，如果省略地址，则服务器将监听所有地址。 如果不包含 <code>listen</code> 指令，则根据超级用户权限，“标准”端口为 <code>80/tcp</code>，“默认”端口为 <code>8000/tcp</code>。</p><p>如果有多个 <code>server</code> 块与同一个 IP 地址和端口的请求匹配，nginx 会使用 <code>server</code> 块中 <code>server_name</code> 指令来测试请求的 <code>Host</code> 头字段。 <code>server_name</code> 指令的参数可以是完整名字、通配符（一个包含 <code>*</code> 字符的字符串）或者正则表达式。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server_name</span> example.org www.example.org</span><span class="token punctuation">;</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果有多个 <code>server_name</code> 都与请求的 <code>Host</code> 头字段匹配，nginx 通过以下规则顺序来确定匹配哪一个：</p><ol><li>完整的名字</li><li>以 <code>*</code> 开头的最长的通配符，例如 <code>*.example.org</code></li><li>以 <code>*</code> 结尾的最长的通配符，例如 <code>mail.*</code></li><li>第一个匹配的正则表达式（以 <code>server</code> 块出现的顺序）</li></ol><p>如果请求的 <code>Host</code> 头字段不匹配任何一个 <code>server_name</code>，nginx 会将请求路由到请求到达端口的默认服务器。除非你在 <code>listen</code> 指令中包含 <code>default_server</code> 参数来明确指定该 <code>server</code> 块为默认服务器，否者 <code>nginx.conf</code> 文件中的第一个 <code>server</code> 块为默认服务器。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  listen 80 default_server
<span class="token punctuation">}</span>
</code></pre></div><h3 id="configuring-locations" tabindex="-1">Configuring Locations <a class="header-anchor" href="#configuring-locations" aria-hidden="true">#</a></h3><p>可以在 <code>server</code> 块中定义 <code>location</code> 块来处理具体的请求，例如将一些请求转发到某个代理服务器，再将一些请求转发到另外的代理服务器，然后对剩下的请求响应本地的静态文件等等。</p><p>nginx 使用请求的 URI 来测试所有 <code>location</code> 指令的参数，然后使用匹配的 <code>location</code> 块来处理该请求。在每个 <code>location</code> 块内，通常可以（有一些例外）放置更多的 <code>location</code> 指令，以进一步优化特定请求组的处理。</p><p><code>location</code> 指令有两种类型的参数：前缀字符串（pathname）和正则表达式。一个请求的 URI 要匹配一个前缀字符串，它必须要以该前缀字符串开头</p><p>例如下面具有前缀字符串参数的 <code>location</code> 块会匹配 URI 以 <code>/some/path/</code> 开头的请求，例如 <code>/some/path/document.html</code>:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正则表达式参数通过 <code>~</code> （大小写敏感） 或 <code>~*</code> （大小写不敏感） 符号来指示，例如下面的 <code>location</code> 块匹配所有 URI 包含 <code>.html</code> 或 <code>.htm</code> 的请求：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> ~ \.html?</span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="location-priority" tabindex="-1">Location Priority <a class="header-anchor" href="#location-priority" aria-hidden="true">#</a></h3><p>为了找到与请求的 URI 最匹配的 <code>location</code> 块，nginx 首先比较前缀字符串类型的 <code>location</code> 块，然后再去查找正则表达式类型的 <code>location</code> 块。</p><p>除非在前缀字符串前面使用了 <code>^~</code> 修饰符，否则正则表达式具有更高的优先级。nginx 确定最佳匹配的 <code>location</code> 块的逻辑如下：</p><ol><li>用 URI 检查所有前缀字符串</li><li><code>=</code> 修饰符定义了请求 URI 和前缀字符串的精确匹配，如果存在精确匹配，停止查找，该 <code>location</code> 块为最佳匹配</li><li>如果与 URI 匹配的最长的前缀字符串的前面存在 <code>^~</code> 修饰符，则跳过正则表达式的检查，该最长的前缀字符串为最佳匹配</li><li>保存匹配的最长前缀字符串</li><li>用 URI 测试正则表达式</li><li>当找到第一个匹配的正则表达式时，停止查找，该 <code>location</code> 块为最佳匹配</li><li>如果没有找到匹配的正则表达式，使用前面匹配的最长前缀字符串对应的 <code>location</code> 块</li></ol><p>关于 <code>=</code> 修饰符，一个典型的用法是针对 <code>/</code> 的请求。如果客户端会频繁发起 URI 为 <code>/</code> 的请求，为 <code>location</code> 块指定 <code>= /</code> 作为参数，可以加速请求的处理。因为 nginx 在第一次比较后就能确定最匹配的 <code>location</code> 块：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> = /</span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个 <code>location</code> 块可以包含处理请求的指令，例如提供静态文件或者将请求转发到代理服务器。下面的例子中，匹配第一个 <code>location</code> 块的请求将会获取到本地系统 <code>/data</code> 目录下对应的文件，而匹配第二个 <code>location</code> 块的请求会被转发到域名为 <code>www.example.com</code> 的代理服务器:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">root</span> /data</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    proxy_pass http://www.example.com
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>root</code> 指令指定一个文件系统路径，指明从哪里去找要服务的文件，将与该 <code>location</code> 块匹配的 URI 添加到 root 路径后面就得到要请求的文件的完整路径，例如在上面的例子中，要响应 URI 为 <code>/images/example.png</code> 的请求，nginx 需要提供路径为 <code>/data/images/example.png</code> 的文件。</p><p><code>proxy_pass</code> 指令会将请求转发到该指令参数指定的代理服务器上，来自代理服务器的响应会被发送回客户端。上面的例子中所有 URI 不以 <code>/images/</code> 开头的请求都将被转发到代理服务器。</p><h3 id="using-variables" tabindex="-1">Using Variables <a class="header-anchor" href="#using-variables" aria-hidden="true">#</a></h3><p>在配置文件中使用变量，可以让 nginx 根据不用的情形处理不同的请求。变量可以用作指令的参数，它在运行时阶段被解析。变量名需要以 <code>$</code> 符号开头。变量根据 nginx 的状态定义信息，例如当前正在处理的请求的属性。</p><p>有很多已经定义好的变量，例如 <a href="https://nginx.org/en/docs/http/ngx_http_core_module.html?&amp;_ga=2.148382143.964290018.1595647568-1083603121.1582961132#variables" target="_blank" rel="noopener noreferrer">core HTTP</a> 变量，你可以使用 <code>set</code>，<code>map</code> 和 <code>geo</code> 指令定义自己的变量。 大多数变量是在运行时计算的，并且包含与特定请求有关的信息。 例如，<code>$remote_addr</code> 包含客户端 IP 地址，而 <code>$uri</code> 是当前请求的 URI 值。</p><h3 id="returning-specific-status-codes" tabindex="-1">Returning Specific Status Codes <a class="header-anchor" href="#returning-specific-status-codes" aria-hidden="true">#</a></h3><p>某些网站 URI 要求立即返回带有特定错误或重定向代码的响应，例如当页面已临时或永久移除时，最简单的方法是使用 return 指令：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /wrong/url</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">return</span> <span class="token number">404</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>return</code> 指令的第一个参数是响应状态码。可选的第二个参数可以是重定向的 URL（用于代码 301、302、303 和 307），也可以是要在响应正文中返回的文本。例如：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /permanently/moved/url</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">return</span> <span class="token number">301</span> http://www.example.com/moved/here</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>return</code> 指令可以包含在 <code>location</code> 和 <code>server</code> 上下文中。</p><h3 id="rewriting-uris-in-requests" tabindex="-1">Rewriting URIs in Requests <a class="header-anchor" href="#rewriting-uris-in-requests" aria-hidden="true">#</a></h3><p>在请求处理期间，可以使用 <code>rewrite</code> 指令对请求 URI 进行多次修改，该指令具有一个可选参数和两个必需参数。第一个参数（必需）是请求 URI 必须匹配的正则表达式。第二个参数是用于替换匹配 URI 的 URI。可选的第三个参数是一个标志，它可以停止其它 <code>rewrite</code> 指令的进一步处理或发送重定向（代码 301 或 302）。例如：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /users/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">rewrite</span> ^/users/(.*)$ /show?user=<span class="token variable">$1</span> break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上例所示，第二个参数中的 <code>user</code> 通过匹配正则表达式来捕获。</p><p>您可以在 <code>server</code> 和 <code>location</code> 上下文中包含多个 <code>rewrite</code> 指令。nginx 会按指令的出现顺序依次执行它们。 一旦某个 <code>server</code> 上下文被选中后，该 <code>server</code> 上下文中的 <code>rewrite</code> 指令将被执行。</p><p>nginx 处理了一组 <code>rewrite</code> 指令后，它将根据新的 URI 选择 <code>location</code> 块。如果所选 <code>location</code> 块包含 <code>rewrite</code> 指令，则会依次执行它们，如果 URI 与任何一个都匹配，则在处理所有定义的 <code>rewrite</code> 指令之后，将开始对新的 <code>location</code> 进行搜索</p><p>以下示例展示了 <code>rewrite</code> 指令和 <code>return</code> 指令的组合:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment">#...</span>
    <span class="token directive"><span class="token keyword">rewrite</span> ^(/download/.*)/media/(\w+)\.?.*$ <span class="token variable">$1</span>/mp3/<span class="token variable">$2</span>.mp3 last</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">rewrite</span> ^(/download/.*)/audio/(\w+)\.?.*$ <span class="token variable">$1</span>/mp3/<span class="token variable">$2</span>.ra  last</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">return</span>  <span class="token number">403</span></span><span class="token punctuation">;</span>
    <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此示例配置区分两组 URI。例如诸如 <code>/download/some/media/file</code> 之类的 URI 被改写为 <code>/download/some/mp3/file.mp3</code>，由于 <code>last</code> 标志，后面的指令（第二个 <code>rewrite</code> 指令和 <code>return</code> 指令）会被跳过，但 nginx 会继续处理这个被重写了 URI 的请求。如果 URI 与任何一个 <code>rewrite</code> 指令都不匹配，则 nginx 会将 403 错误代码返回给客户端。</p><p>有两个参数可中断对 <code>rewrite</code> 指令的处理：</p><ul><li><code>last</code>: 停止执行当前 <code>server</code> 或 <code>location</code> 上下文中的 <code>rewrite</code> 指令，但是 nginx 将搜索与重写的 URI 匹配的 <code>location</code>，并且将应用新 <code>location</code> 中的 <code>rewrite</code> 指令（这意味着可以再次更改 URI）。</li><li><code>break</code>: 与 <code>last</code> 指令类似，在当前上下文中停止处理 <code>rewrite</code> 指令，并取消对与新 URI 匹配的 <code>location</code> 的搜索。不执行新 <code>location</code> 中的 <code>rewrite</code> 指令。</li></ul><h3 id="handling-errors" tabindex="-1">Handling Errors <a class="header-anchor" href="#handling-errors" aria-hidden="true">#</a></h3><p>使用 <code>error_page</code> 指令，你可以配置 nginx 以返回自定义页面以及错误代码，在响应中替换不同的错误代码，或者将浏览器重定向到其他 URI。在下面的示例中，<code>error_page</code> 指令指定要返回的页面（<code>/404.html</code>），并带有 <code>404</code> 错误代码</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">error_page</span> <span class="token number">404</span> /404.html</span><span class="token punctuation">;</span>
</code></pre></div><p>请注意，该指令并不意味着立即返回错误（<code>return</code> 指令可以立即返回），而只是指定错误发生时的处理方式。错误代码可能来自代理服务器，也可能发生在 nginx 处理过程中（例如，当 nginx 无法找到客户端请求的文件时，显示 <code>404</code> 错误）。</p><p>在以下示例中，当 nginx 无法找到页面时，它用代码 <code>301</code> 替换代码 <code>404</code>，并将客户端重定向到 <code>http://example.com/new/path.html</code>。 当客户端仍尝试使用其旧 URI 访问页面时，此配置很有用。 <code>301</code> 代码通知浏览器该页面已永久转移，并且需要在返回时自动用新地址替换旧地址：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /old/path.html</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">error_page</span> <span class="token number">404</span> =301 http://example.com/new/path.html</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以下配置是在找不到文件时将请求传递到代理服务器的示例。由于在 <code>error_page</code> 指令中的等号后没有指定状态码，因此会将代理服务器返回的状态码返回给客户端（不一定是 404）</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    ...
    <span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
        <span class="token comment"># Set the root directory to search for the file</span>
        <span class="token directive"><span class="token keyword">root</span> /data/www</span><span class="token punctuation">;</span>

        <span class="token comment"># Disable logging of errors related to file existence</span>
        <span class="token directive"><span class="token keyword">open_file_cache_errors</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>

        <span class="token comment"># Make an internal redirect if the file is not found</span>
        <span class="token directive"><span class="token keyword">error_page</span> <span class="token number">404</span> = /fetch<span class="token variable">$uri</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token directive"><span class="token keyword">location</span> /fetch/</span> <span class="token punctuation">{</span>
        <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend/</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>error_page</code> 指令指示 nginx 在找不到文件时进行内部重定向。 <code>error_page</code> 的指令参数中的 <code>$uri</code> 变量为当前请求的 URI，该 URI 在重定向中传递。</p><p>例如，如果未找到 <code>/images/some/file</code>，则将其替换为 <code>/fetch/images/some/file</code>，并开始对 <code>location</code> 进行新的搜索。 最终该请求匹配到第二个 <code>location</code> 块，并被代理到 <code>http://backend/</code>。</p><p><code>open_file_cache_errors</code> 指令可阻止在找不到文件时记录错误消息。由于丢失的文件已得到正确处理，因此此处没有必要记录错误信息。</p><h2 id="serving-static-content" tabindex="-1">Serving Static Content <a class="header-anchor" href="#serving-static-content" aria-hidden="true">#</a></h2><h3 id="root-directory-and-index-files" tabindex="-1">Root Directory and Index Files <a class="header-anchor" href="#root-directory-and-index-files" aria-hidden="true">#</a></h3><p><code>root</code> 指令指定用于搜索文件的根目录。为了获得请求文件的完整路径，nginx 将请求 URI 附加到 <code>root</code> 指令指定的路径上。<code>root</code> 指令可以位于 <code>http</code>, <code>server</code> 或 <code>location</code> 上下文中。在下面的例子中，<code>root</code> 指令定义在 <code>server</code> 块中，它会被应用到该 <code>server</code> 上下文中所有不包含 <code>root</code> 指令的 <code>location</code> 块：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">root</span> /www/data</span><span class="token punctuation">;</span>

  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token comment">#...</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
    <span class="token comment">#...</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">location</span> ~ \.(mp3|mp4)</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">root</span> /www/media</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里，如果请求 URI 以 <code>/images/</code> 开头，nginx 会在 <code>/www/data/images/</code> 中查找对应的文件，但如果请求 URI 以 <code>.mp3</code> 或 <code>.mp4</code> 结尾，nginx 将会到 <code>/www/media/</code> 目录下去查找相应的文件，因为在匹配的 <code>location</code> 块中包含 <code>root</code> 指令，且改写了要查找的根目录。</p><p>如果请求以 <code>/</code> 结尾，则 nginx 将其视为对目录的请求，并尝试在目录中查找索引文件，<code>index</code> 指令定义了索引文件的名称（默认值为 <code>index.html</code>）。继续上面的示例，如果请求 URI 为 <code>/images/some/path/</code>，则 nginx 会提供文件 <code>/www/data/images/some/path/index.html</code>（如果存在）。 如果该文件不存在，则默认情况下，nginx 返回 404 状态码（Not Found）。若要将 nginx 配置为返回自动生成的目录列表，可以在启用 <code>autoindex</code> 指令：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">autoindex</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>您可以在 <code>index</code> 指令中列出多个文件名。 nginx 按照指定的顺序搜索文件，并返回找到的第一个文件。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">index</span> index.<span class="token variable">$geo</span>.html index.htm index.html</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此处使用的 <code>$geo</code> 变量是通过 <code>geo</code> 指令设置的自定义变量。变量的值取决于客户端的 IP 地址。</p><p>为了返回索引文件，nginx 会将索引文件的名称附加到原先 URI 之后，然后对这个新的 URI 进行内部重定向。内部重定向会导致对 <code>location</code> 进行新的搜索，并且可能会在另一个 <code>location</code> 中结束，如以下示例所示：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">root</span> /data</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">index</span> index.html index.php</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">location</span> ~ \.php</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">fastcgi_pass</span> localhost:8000</span><span class="token punctuation">;</span>
    <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里，如果请求的 URI 为 <code>/path/</code>，并且 <code>/data/path/index.html</code> 不存在，但 <code>/data/path/index.php</code> 存在，则对 <code>/path/index.php</code> 的内部重定向将匹配到第二个 <code>location</code>。 所以，该请求被代理。</p><h3 id="trying-several-options" tabindex="-1">Trying Several Options <a class="header-anchor" href="#trying-several-options" aria-hidden="true">#</a></h3><p><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html?&amp;_ga=2.60795818.660262503.1596359668-1083603121.1582961132#try_files" target="_blank" rel="noopener noreferrer"><code>try_files</code></a> 指令可用于检查指定的文件或目录是否存在。nginx 会进行内部重定向，否则会返回指定的状态码。例如，要检查是否存在与请求 URI 对应的文件，可以使用 <code>try_files</code> 指令和 <code>$uri</code> 变量，如下所示：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">root</span> /www/data</span><span class="token punctuation">;</span>

    <span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
        <span class="token directive"><span class="token keyword">try_files</span> <span class="token variable">$uri</span> /images/default.gif</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该文件以 URI 的形式指定，该 URI 使用当前 <code>location</code> 或 <code>server</code> 上下文中设置的 <code>root</code> 或 <code>alias</code> 指令进行处理。 在上面的例子下，如果不存在与 <code>$uri</code> 对应的文件，则 nginx 将内部重定向到最后一个参数指定的 URI，并返回 <code>/www/data/images/default.gif</code>。</p><p>最后一个参数也可以是状态码（直接放在等号之后）或 <code>location</code> 块的名称。在下面的示例中，如果 <code>try_files</code> 指令的所有参数指定的路径都找不到对应的文件或目录，则返回 404 错误：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">try_files</span> <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ <span class="token variable">$uri</span>.html =404</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在下面的示例中，如果根据 <code>$uri</code> 或 <code>$uri/</code> 都找不到对应的文件或目录，则该请求将被重定向到指定的 <code>location</code> 块，该 <code>location</code> 块会将请求传递给代理服务器。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">try_files</span> <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ @backend</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">location</span> @backend</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend.example.com</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="optimizing-performance-for-serving-content" tabindex="-1">Optimizing Performance for Serving Content <a class="header-anchor" href="#optimizing-performance-for-serving-content" aria-hidden="true">#</a></h3><h4 id="enabling-sendfile" tabindex="-1">Enabling <code>sendfile</code> <a class="header-anchor" href="#enabling-sendfile" aria-hidden="true">#</a></h4><p>默认情况下，nginx 会自行处理文件传输，并在发送文件之前将文件复制到缓冲区中。启用 <code>sendfile</code> 指令会去除将数据复制到缓冲区的步骤，并允许将数据从一个文件描述符直接复制到另一个文件描述符。另外，为防止一个快速连接完全占用工作进程，可以使用 <code>sendfile_max_chunk</code> 指令限制单个 <code>sendfile()</code> 调用中传输的数据量大小（在此示例中为 1MB）：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /mp3</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">sendfile</span>           <span class="token boolean">on</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">sendfile_max_chunk</span> <span class="token number">1m</span></span><span class="token punctuation">;</span>
    <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="enabling-tcp-nopush" tabindex="-1">Enabling <code>tcp_nopush</code> <a class="header-anchor" href="#enabling-tcp-nopush" aria-hidden="true">#</a></h3><p>将 <code>tcp_nopush</code> 指令与 <code>sendfile on</code> 指令一起使用，可以让 nginx 在 <code>sendfile()</code> 获得数据块之后立即在一个数据包中发送 HTTP 响应头：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /mp3</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">sendfile</span>   <span class="token boolean">on</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">tcp_nopush</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>
    <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="nginx-reverse-proxy" tabindex="-1">NGINX Reverse Proxy <a class="header-anchor" href="#nginx-reverse-proxy" aria-hidden="true">#</a></h2><h3 id="passing-a-request-to-a-proxied-server" tabindex="-1">Passing a Request to a Proxied Server <a class="header-anchor" href="#passing-a-request-to-a-proxied-server" aria-hidden="true">#</a></h3><p>当 nginx 代理请求时，它将请求发送到指定的代理服务器，获取响应，然后将其发送回客户端。可以使用指定协议将请求代理到 HTTP 服务器（另一个 nginx 服务器或任何其他服务器）或非 HTTP 服务器（可以运行使用特定框架开发的应用程序，例如 PHP 或 Python）。 支持的协议包括 <code>FastCGI</code>，<code>uwsgi</code>，<code>SCGI</code> 和 <code>memcached</code>。</p><p>要将请求传递到 HTTP 代理服务器，必须在一个 <code>location</code> 块内使用 <code>proxy_pass</code> 指令， 例如：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://www.example.com/link/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>下面的例子会将所有匹配到这个 <code>location</code> 块的请求转发到指定的代理服务器，转发的地址可以是一个域名或 IP 地址，同时也可以包含一个端口：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> ~ \.php</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://127.0.0.1:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果代理服务器的地址以一个 URI 结尾，nginx 会用该地址替换请求 URI 中与 <code>location</code> 参数匹配的部分。例如上面第一个例子中，代理服务器的地址以 <code>/link/</code> 结尾，那么对于 URI 为 <code>/some/path/page.html</code> 的请求，将会被代理到 <code>http://www.example.com/link/page.html</code>。如果 <code>proxy_pass</code> 指定的地址不包含 URI ，或者无法确定要替换的 URI 部分，则会传递完整的请求 URI。</p><p>要将请求传递到非 HTTP 代理服务器，应使用适当的 <code>**_ pass</code> 指令：</p><ul><li><code>fastcgi_pass</code> 传递请求到一个 FastCGI 服务器</li><li><code>uwsgi_pass</code> 传递请求到一个 uwsgi 服务器</li><li><code>scgi_pass</code> 传递请求到一个 SCGI 服务器</li><li><code>memcached_pass</code> 传递请求到一个 memcached 服务器</li></ul><h3 id="passing-request-headers" tabindex="-1">Passing Request Headers <a class="header-anchor" href="#passing-request-headers" aria-hidden="true">#</a></h3><p>默认情况下，nginx 在代理请求中会重新定义两个头字段 &quot;Host&quot; 和 &quot;Connection&quot;，并去除值为空字符串的头字段。默认 &quot;Host&quot; 设置为 <code>$proxy_host</code> 变量，&quot;Connection&quot; 设置为 <code>close</code>。</p><p>要更改这些设置以及修改其它头字段，可以使用 <code>proxy_set_header</code> 指令。可以在 <code>location</code> 块中指定该指令。也可以在特定的 <code>server</code> 上下文或 <code>http</code> 块中指定它。例如：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个配置中，头字段 &quot;Host&quot; 被设置为 <code>$host</code> 变量.</p><p>若要阻止某个头字段传递到代理服务器，请将其设置为空字符串：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> Accept-Encoding <span class="token string">&quot;&quot;</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="configuring-buffers" tabindex="-1">Configuring Buffers <a class="header-anchor" href="#configuring-buffers" aria-hidden="true">#</a></h3><p>默认情况下，nginx 缓冲来自代理服务器的响应。响应存储在内部缓冲区中，直到接收到整个响应后才发送给客户端。 缓冲有助于优化客户端的性能，如果将响应从 nginx 同步传递到客户端，这可能会浪费代理服务器的时间。但是，如果启用缓冲后，nginx 允许代理服务器快速处理响应，而 nginx 将响应存储的时间与客户端下载响应所需的时间一样长。</p><p>负责启用和禁用缓冲的指令是 <code>proxy_buffering</code>。 默认情况下，它设置为 <code>on</code> 即启用了缓冲。</p><p><code>proxy_buffers</code> 指令控制为请求分配的缓冲区的大小和数量。来自代理服务器的响应的第一部分存储在单独的缓冲区中，缓冲区的大小由 <code>proxy_buffer_size</code> 指令设置。这部分通常包含一个相对较小的响应头，并且可以使其小于其余响应的缓冲区。</p><p>在下面的示例中，增加了默认缓冲区数，并使响应第一部分的缓冲区大小小于默认值。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_buffers</span> <span class="token number">16</span> <span class="token number">4k</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_buffer_size</span> <span class="token number">2k</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果禁用了缓冲，则 nginx 会将从代理服务器接收到的响应同步发送到客户端。对于需要尽快开始接收响应的快速交互客户端，这可能是需要的行为。</p><p>要在特定 <code>location</code> 中禁用缓冲，请 <code>location</code> 中将 <code>proxy_buffering</code> 设置为 <code>off</code>，如下：</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_buffering</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这种情况下，nginx 仅使用 <code>proxy_buffer_size</code> 配置的缓冲区来存储响应的当前部分。</p></div></div><footer class="page-footer" data-v-8fcebc32 data-v-5c96fb00><div class="edit" data-v-5c96fb00><div class="edit-link" data-v-5c96fb00 data-v-55695e90><!----></div></div><div class="updated" data-v-5c96fb00><!----></div></footer><div class="next-and-prev-link" data-v-8fcebc32 data-v-e65a9748><div class="container" data-v-e65a9748><div class="prev" data-v-e65a9748><a class="link" href="/yangss/notes/linux" data-v-e65a9748><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-e65a9748><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-e65a9748>Linux 相关</span></a></div><div class="next" data-v-e65a9748><a class="link" href="/yangss/notes/package-json" data-v-e65a9748><span class="text" data-v-e65a9748>package.json 配置说明</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-e65a9748><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"readme.md\":\"9c437d66\",\"articles_async-setup.md\":\"aad569cd\",\"articles_excess-property-checking-in-typescript.md\":\"fc70c275\",\"articles_explaining-proxy-and-reflect-in-detail.md\":\"fd48ae55\",\"articles_how-context-is-used-in-typescript.md\":\"dfbe1fc8\",\"articles_index.md\":\"26900070\",\"articles_settimeout-setinterval.md\":\"e05232df\",\"articles_switch-true-pattern.md\":\"4f62d18a\",\"articles_understand-arraybuffer.md\":\"8c29cf7e\",\"articles_understand-cors.md\":\"8c62e294\",\"articles_understand-ts-type-system.md\":\"126cfee9\",\"articles_understand-unknown-in-typescript.md\":\"414cb8f4\",\"articles_understand-weakmap-and-weakset.md\":\"ebf6a6c8\",\"articles_what-is-blob.md\":\"186220d7\",\"articles_what-is-currying.md\":\"37e4880c\",\"articles_what-is-decorator-pattern.md\":\"a19acd7e\",\"bookmarks.md\":\"5f5e0286\",\"index.md\":\"827dab7f\",\"notes_git.md\":\"59832f2f\",\"notes_index.md\":\"57401c5b\",\"notes_linux.md\":\"6d6e659a\",\"notes_nginx.md\":\"1ca49aba\",\"notes_package-json.md\":\"83af1eb0\",\"notes_pkg-manager.md\":\"43bbf52c\",\"notes_regexp.md\":\"4934ad21\",\"notes_type-challenges.md\":\"cee01304\",\"notes_typescript.md\":\"12d7a6e8\",\"projects.md\":\"8ebb443c\"}")</script>
    <script type="module" async src="/yangss/assets/app.df974142.js"></script>
    
  </body>
</html>