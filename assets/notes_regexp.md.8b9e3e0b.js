import{_ as s,c as n,o as a,a as e}from"./app.e2cd98b5.js";const p='{"title":"正则表达式","description":"","frontmatter":{},"headers":[{"level":2,"title":"捕获组","slug":"捕获组"},{"level":2,"title":"断言","slug":"断言"},{"level":2,"title":"匹配中文字符","slug":"匹配中文字符"}],"relativePath":"notes/regexp.md","lastUpdated":1640876420267}',t={},o=[e('<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-hidden="true">#</a></h1><h2 id="捕获组" tabindex="-1">捕获组 <a class="header-anchor" href="#捕获组" aria-hidden="true">#</a></h2><ul><li><strong>捕获组</strong> <code>(xyz)</code> 和 <code>\\n</code>：<code>(xyz)</code> 匹配 <code>&#39;xyz&#39;</code> 并且会记住这个匹配，一个正则表达式可以包含多个捕获组，可以在后面通过 <code>\\n</code> 来引用对应的捕获组，其中 <code>n</code> 代表捕获组出现的顺序，例如 <code>\\1</code> 代表引用第一个捕获组：<div class="language-js"><pre><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">My favorite fruit is (apple), I eat \\d+ \\1s? a day</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;My favorite fruit is apple, I eat 3 apples a day&#39;</span><span class="token punctuation">)</span>\n<span class="token comment">// [&#39;My favorite fruit is apple, I eat 3 apples a day&#39;, &#39;apple&#39;, index: 0, input: &#39;My favorite fruit is apple, I eat 3 apples a day&#39;, groups: undefined]</span>\n</code></pre></div></li><li><strong>命名的捕获组</strong> <code>(?&lt;name&gt;xyz)</code> 和 <code>\\k&lt;name&gt;</code>：通过 <code>?&lt;name&gt;</code> 标记给捕获组命名。命名的捕获组可以通过 <code>\\k&lt;name&gt;</code> 的方式引用，而且在匹配结果中，命名的捕获组的匹配结果会出现在 <code>groups</code> 字段中，可以通过 <code>res.groups.[name]</code> 来访问：<div class="language-js"><pre><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">My favorite fruit is (?&lt;fruit&gt;apple), I eat \\d+ \\k&lt;fruit&gt;s? a day</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;My favorite fruit is apple, I eat 3 apples a day&#39;</span><span class="token punctuation">)</span>\n<span class="token comment">// [&#39;My favorite fruit is apple, I eat 3 apples a day&#39;, &#39;apple&#39;, index: 0, input: &#39;My favorite fruit is apple, I eat 3 apples a day&#39;, groups: {fruit: &#39;apple&#39;}]</span>\n</code></pre></div></li><li><strong>非捕获组</strong> <code>(?:xyz)</code>：匹配 <code>&#39;xyz&#39;</code>，但是结果不会记住这个匹配组，即从匹配结果里获取不到匹配的子串。如果我们只需要对匹配进行分组，而不需要记住这个分组时，可以给分组添加 <code>?:</code> 标记，这样性能会更好：<div class="language-js"><pre><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">My favorite fruit is (?:apple|pineapple)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;My favorite fruit is apple&#39;</span><span class="token punctuation">)</span>\n <span class="token comment">// [&#39;My favorite fruit is apple&#39;, index: 0, input: &#39;My favorite fruit is apple&#39;, groups: undefined]</span>\n</code></pre></div></li></ul><h2 id="断言" tabindex="-1">断言 <a class="header-anchor" href="#断言" aria-hidden="true">#</a></h2><ul><li><strong>向前肯定断言</strong> <code>x(?=y)</code>：匹配 <code>&#39;x&#39;</code> 当且仅当 <code>&#39;x&#39; 后面紧跟着 &#39;y&#39;</code><div class="language-js"><pre><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">Nicholas(?=Yang)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;NicholasYang&#39;</span><span class="token punctuation">)</span>\n<span class="token comment">// [&#39;Nicholas&#39;, index: 0, input: &#39;NicholasYang&#39;, groups: undefined]</span>\n\n<span class="token operator">/</span><span class="token function">Nicholas</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">=</span>Yang<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;Nicholas123&#39;</span><span class="token punctuation">)</span>\n<span class="token comment">// null</span>\n</code></pre></div></li><li><strong>向前否定断言</strong> <code>x(?!y)</code>：匹配 <code>&#39;x&#39;</code> 当且仅当 <code>&#39;x&#39; 后面不是紧跟着 &#39;y&#39;</code><div class="language-js"><pre><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\d+(?!\\.)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;3.14&#39;</span><span class="token punctuation">)</span>\n<span class="token comment">// [&#39;14&#39;, index: 2, input: &#39;3.14&#39;, groups: undefined]</span>\n<span class="token comment">// 匹配 &#39;14&#39; 而不是 &#39;3&#39;</span>\n</code></pre></div></li><li><strong>向后肯定断言</strong> <code>(?&lt;=y)x</code>：匹配 <code>&#39;x&#39;</code> 当且仅当 <code>&#39;x&#39; 前面是 &#39;y&#39;</code><div class="language-js"><pre><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=Nicholas)Yang</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;NicholasYang&#39;</span><span class="token punctuation">)</span>\n<span class="token comment">// [&#39;Yang&#39;, index: 8, input: &#39;NicholasYang&#39;, groups: undefined]</span>\n</code></pre></div></li><li><strong>向后否定断言</strong> <code>(?&lt;!y)x</code>：匹配 <code>&#39;x&#39;</code> 当且仅当 <code>&#39;x&#39; 前面不是 &#39;y&#39;</code><div class="language-js"><pre><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;!-)\\d+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;3&#39;</span><span class="token punctuation">)</span> <span class="token comment">// match</span>\n<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">-</span><span class="token punctuation">)</span>\\d<span class="token operator">+</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;-3&#39;</span><span class="token punctuation">)</span> <span class="token comment">// not match</span>\n</code></pre></div></li></ul><h2 id="匹配中文字符" tabindex="-1">匹配中文字符 <a class="header-anchor" href="#匹配中文字符" aria-hidden="true">#</a></h2><p>当需要匹配中文字符时，你通过百度很快就能找到这段正则表达式：</p><div class="language-js"><pre><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\u4E00-\\u9FCC\\u3400-\\u4DB5\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\ud840-\\ud868][\\udc00-\\udfff]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|[\\ud86a-\\ud86c][\\udc00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d]</span><span class="token regex-delimiter">/</span></span>\n</code></pre></div><p>这样做没问题，但是看起来很不优雅。还有一种更简洁的办法，即 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes" target="_blank" rel="noopener noreferrer">unicode property escapes</a>，基于字符的 unicode 进行匹配，需要配合 <code>u</code> 修饰符使用：</p><div class="language-js"><pre><code><span class="token keyword">const</span> chineseCharRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\p{Script=Han}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span> <span class="token comment">// Script 可以简写为 sc</span>\nchineseCharRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;你好&#39;</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre></div>',10)];var c=s(t,[["render",function(s,e,p,t,c,l){return a(),n("div",null,o)}]]);export{p as __pageData,c as default};
