import{_ as n,r as s,c as a,b as t,d as e,e as o,o as l}from"./app.df974142.js";const c='{"title":"深入理解 TypeScript 的类型系统","description":"","frontmatter":{},"headers":[{"level":2,"title":"把类型看作值的集合","slug":"把类型看作值的集合"},{"level":2,"title":"总结","slug":"总结"}],"relativePath":"articles/understand-ts-type-system.md","lastUpdated":1649689878657}',p={},u=e("h1",{id:"深入理解-typescript-的类型系统",tabindex:"-1"},[o("深入理解 TypeScript 的类型系统 "),e("a",{class:"header-anchor",href:"#深入理解-typescript-的类型系统","aria-hidden":"true"},"#")],-1),r=e("h2",{id:"把类型看作值的集合",tabindex:"-1"},[o("把类型看作值的集合 "),e("a",{class:"header-anchor",href:"#把类型看作值的集合","aria-hidden":"true"},"#")],-1),k=e("p",null,"把 TypeScript 中的类型看作一组可能的值的集合，这有助于你更好的理解 TypeScript 中的类型和类型操作。",-1),i=e("p",null,[o("例如，你可以把 "),e("code",null,"number"),o(" 类型看成是所有数值的集合。"),e("code",null,"42"),o(" 和 "),e("code",null,"-37"),o(" 都在其中，但是 "),e("code",null,"'hello'"),o(" 不在其中。根据是否设置 "),e("code",null,"strictNullChecks"),o("，"),e("code",null,"null"),o(" 和 "),e("code",null,"undefined"),o(" 可能是也可能不是这个集合的一部分：")],-1),d=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"let"),o(" num"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"number"),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token number"},"42"),o(),e("span",{class:"token comment"},"// ok"),o("\nnum "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token operator"},"-"),e("span",{class:"token number"},"37"),o(),e("span",{class:"token comment"},"// ok"),o("\nnum "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token string"},"'hello'"),o(),e("span",{class:"token comment"},"// ~ Type string is not assignable to type number"),o("\n")])])],-1),y=e("p",null,[o("最小的集合是空集，它对应于 TypeScript 中的 "),e("code",null,"never"),o(" 类型。因为空集不包含任何值，所以任何值都不能赋值给一个具有 "),e("code",null,"never"),o(" 类型的变量：")],-1),m=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"const"),o(" x"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"never"),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token number"},"12"),o(),e("span",{class:"token comment"},"// ~ Type '12' is not assignable to type 'never'"),o("\n")])])],-1),g=e("p",null,"其次最小的集合就是只包含一个值的集合，这对应于 TypeScript 中的字面类型(literal type），例如：",-1),b=e("div",{class:"language-js"},[e("pre",null,[e("code",null,[o("type "),e("span",{class:"token constant"},"A"),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token string"},"'A'"),o("\ntype "),e("span",{class:"token constant"},"B"),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token string"},"'B'"),o("\ntype Three "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token number"},"3"),o("\n")])])],-1),f=e("p",null,[o("可以将多个集合求并集生成一个新的集合，这对应于 TypeScript 中的联合类型，类型操作 "),e("code",null,"|"),o(" 可以理解为集合求并集操作：")],-1),w=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"type"),o(),e("span",{class:"token class-name"},[e("span",{class:"token constant"},"AB")]),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token string"},"'A'"),o(),e("span",{class:"token operator"},"|"),o(),e("span",{class:"token string"},"'B'"),o("\n"),e("span",{class:"token keyword"},"type"),o(),e("span",{class:"token class-name"},[e("span",{class:"token constant"},"AB3")]),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token string"},"'A'"),o(),e("span",{class:"token operator"},"|"),o(),e("span",{class:"token string"},"'B'"),o(),e("span",{class:"token operator"},"|"),o(),e("span",{class:"token number"},"3"),o("\n")])])],-1),h=e("p",null,"类型 B 能赋给（assignable to）类型 A，当且仅当类型 B 代表的集合是类型 A 代表的集合的子集（subset），实际上，这正是 TypeScript 的类型检查的本质：",-1),T=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"const"),o(" ab"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token constant"},"AB"),o(),e("span",{class:"token operator"},"="),o(" Math"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"random"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token operator"},">"),o(),e("span",{class:"token number"},"0.5"),o(),e("span",{class:"token operator"},"?"),o(),e("span",{class:"token string"},"'A'"),o(),e("span",{class:"token operator"},":"),o(),e("span",{class:"token string"},"'B'"),o(),e("span",{class:"token comment"},'// OK, {"A", "B"} 是 {"A", "B"} 的子集'),o("\n"),e("span",{class:"token keyword"},"const"),o(" ab3"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token constant"},"AB3"),o(),e("span",{class:"token operator"},"="),o(" ab "),e("span",{class:"token comment"},'// OK, {"A", "B"} 是 {"A", "B", 3} 的子集'),o("\n\n"),e("span",{class:"token keyword"},"declare"),o(),e("span",{class:"token keyword"},"let"),o(" three"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token constant"},"AB3"),o("\n"),e("span",{class:"token keyword"},"const"),o(" back"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token constant"},"AB"),o(),e("span",{class:"token operator"},"="),o(" three "),e("span",{class:"token comment"},'// Error, {"A", "B", 3} 不是 {"A", "B"} 的子集'),o("\n")])])],-1),v=e("p",null,"上面这些例子都很容易理解，因为这些类型代表的集合都是有限集，但是在实际场景中我们用到的类型很多是无限集，要理解这些类型和类型操作，就不那么容易。例如：",-1),A=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"interface"),o(),e("span",{class:"token class-name"},"Identified"),o(),e("span",{class:"token punctuation"},"{"),o("\n  id"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"string"),o("\n"),e("span",{class:"token punctuation"},"}"),o("\n")])])],-1),S=e("p",null,[o("这个 interface 定义的集合就是一个无限集，它描述的是集合里的每个元素的形状，即必须包含一个 "),e("code",null,"id"),o(" 属性，且这个属性的值的类型必须是 "),e("code",null,"string"),o(" 类型的子集。也就是说，只要一个对象满足这一点，它就属于这个集合，即使它还包含额外的属性。")],-1),x=e("p",null,"理解了这一点可以帮助你更好的理解在这些类型上的类型操作：",-1),B=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"interface"),o(),e("span",{class:"token class-name"},"Person"),o(),e("span",{class:"token punctuation"},"{"),o("\n  name"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"string"),o("\n"),e("span",{class:"token punctuation"},"}"),o("\n"),e("span",{class:"token keyword"},"interface"),o(),e("span",{class:"token class-name"},"Lifespan"),o(),e("span",{class:"token punctuation"},"{"),o("\n  birth"),e("span",{class:"token operator"},":"),o(" Date\n  death"),e("span",{class:"token operator"},"?"),e("span",{class:"token operator"},":"),o(" Date\n"),e("span",{class:"token punctuation"},"}"),o("\n"),e("span",{class:"token keyword"},"type"),o(),e("span",{class:"token class-name"},"PersonSpan"),o(),e("span",{class:"token operator"},"="),o(" Person "),e("span",{class:"token operator"},"&"),o(" Lifespan\n")])])],-1),P=e("p",null,[e("code",null,"&"),o(" 操作符用来计算两个类型的交集，那么哪些值是属于 "),e("code",null,"PersonSpan"),o(" 类型呢？咋一看，"),e("code",null,"Person"),o(" 和 "),e("code",null,"Lifespan"),o(" 没有相同的属性，所以它们的交集应该是空集。是这样吗？")],-1),D=e("p",null,[o("答案是否定的，首先，我们要弄清楚类型操作是作用在"),e("strong",null,"值的集合"),o("上，而不是类型定义的属性上，其次，一个包含额外属性（类型定义里声明的属性之外的属性）的值同样属于这个类型的集合。所以在上面的例子中，如果一个值同时包含 "),e("code",null,"Person"),o(" 和 "),e("code",null,"Lifespan"),o(" 的属性，那么它就属于 "),e("code",null,"PersonSpan"),o(" 类型：")],-1),K=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"const"),o(" ps"),e("span",{class:"token operator"},":"),o(" PersonSpan "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token punctuation"},"{"),o("\n  name"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token string"},"'Alan Turing'"),e("span",{class:"token punctuation"},","),o("\n  birth"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token keyword"},"new"),o(),e("span",{class:"token class-name"},"Date"),e("span",{class:"token punctuation"},"("),e("span",{class:"token string"},"'1912/06/23'"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},","),o("\n  death"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token keyword"},"new"),o(),e("span",{class:"token class-name"},"Date"),e("span",{class:"token punctuation"},"("),e("span",{class:"token string"},"'1954/06/07'"),e("span",{class:"token punctuation"},")"),o("\n"),e("span",{class:"token punctuation"},"}"),o(),e("span",{class:"token comment"},"// Ok"),o("\n")])])],-1),L=e("p",null,"一般的规则是，多个 interface 的交叉类型（intersection type）中的值所包含的属性，是这每个组成的 interface 中的属性的联合（union）。可以用下面的公式来表达：",-1),V=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"keyof"),o(),e("span",{class:"token punctuation"},"("),e("span",{class:"token constant"},"A"),o(),e("span",{class:"token operator"},"&"),o(),e("span",{class:"token constant"},"B"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"keyof"),o(),e("span",{class:"token constant"},"A"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token operator"},"|"),o(),e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"keyof"),o(),e("span",{class:"token constant"},"B"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token comment"},"// (1)"),o("\n")])])],-1),O=e("p",null,"这很容易理解，也是符合直觉的。但是对于多个 interface 的联合类型（union type）来说，就有点绕了：",-1),M=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"type"),o(),e("span",{class:"token class-name"},[e("span",{class:"token constant"},"K")]),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token keyword"},"keyof"),o(),e("span",{class:"token punctuation"},"("),o("Person "),e("span",{class:"token operator"},"|"),o(" Lifespan"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token comment"},"// type K = never"),o("\n")])])],-1),j=e("p",null,[o("为什么是 "),e("code",null,"never"),o("？前面我们说过联合操作 "),e("code",null,"|"),o(" 相当于求并集，"),e("code",null,"Person | Lifespan"),o(" 所代表的集合由所有属于 "),e("code",null,"Person"),o(" 的值和所有属于 "),e("code",null,"Lifespan"),o(" 值组成，例如：")],-1),U=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"const"),o(" p1 "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token punctuation"},"{"),o(" name"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token string"},"'Rose'"),o(),e("span",{class:"token punctuation"},"}"),o("\n"),e("span",{class:"token keyword"},"const"),o(" p2 "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token punctuation"},"{"),o(" name"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token string"},"'Monica'"),e("span",{class:"token punctuation"},","),o(" age"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token number"},"23"),o(),e("span",{class:"token punctuation"},"}"),o("\n"),e("span",{class:"token keyword"},"const"),o(" l1 "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token punctuation"},"{"),o("\n birth"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token keyword"},"new"),o(),e("span",{class:"token class-name"},"Date"),e("span",{class:"token punctuation"},"("),e("span",{class:"token string"},"'1932/06/23'"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},","),o("\n death"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token keyword"},"new"),o(),e("span",{class:"token class-name"},"Date"),e("span",{class:"token punctuation"},"("),e("span",{class:"token string"},"'1992/03/21'"),e("span",{class:"token punctuation"},")"),o("\n"),e("span",{class:"token punctuation"},"}"),o("\n"),e("span",{class:"token keyword"},"const"),o(" l2 "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token punctuation"},"{"),o("\n birth"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token keyword"},"new"),o(),e("span",{class:"token class-name"},"Date"),e("span",{class:"token punctuation"},"("),e("span",{class:"token string"},"'1912/06/23'"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},","),o("\n death"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token keyword"},"new"),o(),e("span",{class:"token class-name"},"Date"),e("span",{class:"token punctuation"},"("),e("span",{class:"token string"},"'1952/03/21'"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},","),o("\n gender"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token string"},"'male'"),o("\n"),e("span",{class:"token punctuation"},"}"),o("\n\n"),e("span",{class:"token keyword"},"let"),o(" p"),e("span",{class:"token operator"},":"),o(" Person "),e("span",{class:"token operator"},"|"),o(" Lifespan "),e("span",{class:"token operator"},"="),o(" p1 "),e("span",{class:"token comment"},"// Ok"),o("\np "),e("span",{class:"token operator"},"="),o(" p2 "),e("span",{class:"token comment"},"// Ok"),o("\np "),e("span",{class:"token operator"},"="),o(" l1 "),e("span",{class:"token comment"},"// Ok"),o("\np "),e("span",{class:"token operator"},"="),o(" l2 "),e("span",{class:"token comment"},"// Ok"),o("\n")])])],-1),z=e("p",null,[o("可以看到 "),e("code",null,"p1"),o("，"),e("code",null,"p2"),o("，"),e("code",null,"l1"),o("，"),e("code",null,"l2"),o(" 都属于 "),e("code",null,"Person | Lifespan"),o(" 类型，但是由于 "),e("code",null,"Person"),o(" 和 "),e("code",null,"Lifespan"),o(" 的接口定义中所描述的属性没有重叠的部分，所以 TypeScript 无法找到某一个属性是 "),e("code",null,"Person | Lifespan"),o(" 这个集合中的每一个值都包含的，例如上面的 "),e("code",null,"p1"),o("，"),e("code",null,"p2"),o(" 和 "),e("code",null,"l1"),o("，"),e("code",null,"l2"),o(" 之间没有共同的属性，但是他们都属于 "),e("code",null,"Person | Lifespan"),o("，所以 TypeScript 推断出 "),e("code",null,"keyof (Person | Lifespan)"),o(" 是空集，即 "),e("code",null,"never"),o("。")],-1),C=e("p",null,"更通用的规则，也可以用下面的公式来表达：",-1),E=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"keyof"),o(),e("span",{class:"token punctuation"},"("),e("span",{class:"token constant"},"A"),o(),e("span",{class:"token operator"},"|"),o(),e("span",{class:"token constant"},"B"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token operator"},"="),o(),e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"keyof"),o(),e("span",{class:"token constant"},"A"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token operator"},"&"),o(),e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"keyof"),o(),e("span",{class:"token constant"},"B"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token comment"},"// (2)"),o("\n")])])],-1),I=e("p",null,"如果你能对 (1)，(2) 这两个公式建立直觉，那么你就朝着深入理解 TypeScript 的类型系统前进了一大步。",-1),N=e("p",null,[o("另一个表达 "),e("code",null,"PersonSpan"),o(" 类型的方法是使用 "),e("code",null,"extends"),o("：")],-1),R=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"interface"),o(),e("span",{class:"token class-name"},"Person"),o(),e("span",{class:"token punctuation"},"{"),o("\n  name"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"string"),o("\n"),e("span",{class:"token punctuation"},"}"),o("\n"),e("span",{class:"token keyword"},"interface"),o(),e("span",{class:"token class-name"},"PersonSpan"),o(),e("span",{class:"token keyword"},"extends"),o(),e("span",{class:"token class-name"},"Person"),o(),e("span",{class:"token punctuation"},"{"),o("\n  birth"),e("span",{class:"token operator"},":"),o(" Date\n  death"),e("span",{class:"token operator"},"?"),e("span",{class:"token operator"},":"),o(" Date\n"),e("span",{class:"token punctuation"},"}"),o("\n")])])],-1),_=e("p",null,[o("如果把类型看作值的集合，那这里的 "),e("code",null,"extends"),o(" 该如何理解？很简单，"),e("code",null,"A extends B"),o("，可以直接理解为 "),e("code",null,"A"),o(" 是 "),e("code",null,"B"),o(" 的子集（subset）。"),e("code",null,"PersonSpan"),o(" 中的值必须包含 "),e("code",null,"name"),o(" 属性且它的值是个 "),e("code",null,"string"),o("，同时也必须包含 "),e("code",null,"birth"),o(" 属性。所以 "),e("code",null,"PersonSpan"),o(" 是一个符合要求的子集。你可能还听过子类型（subtype）的说法，它和这里子集（subset）表达的意思相同。看下面的例子：")],-1),q=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"interface"),o(),e("span",{class:"token class-name"},"Vector1D"),o(),e("span",{class:"token punctuation"},"{"),o(" x"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"number"),o(),e("span",{class:"token punctuation"},"}"),o("\n"),e("span",{class:"token keyword"},"interface"),o(),e("span",{class:"token class-name"},"Vector2D"),o(),e("span",{class:"token keyword"},"extends"),o(),e("span",{class:"token class-name"},"Vector1D"),o(),e("span",{class:"token punctuation"},"{"),o(" y"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"number"),o(),e("span",{class:"token punctuation"},"}"),o("\n"),e("span",{class:"token keyword"},"interface"),o(),e("span",{class:"token class-name"},"Vector3D"),o(),e("span",{class:"token keyword"},"extends"),o(),e("span",{class:"token class-name"},"Vector2D"),o(),e("span",{class:"token punctuation"},"{"),o(" z"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"number"),o(),e("span",{class:"token punctuation"},"}"),o("\n")])])],-1),F=e("p",null,[o("这里你可以说 "),e("code",null,"Vector3D"),o(" 是 "),e("code",null,"Vector2D"),o(" 的子类型，"),e("code",null,"Vector2D"),o(" 又是 "),e("code",null,"Vector1D"),o(" 的子类型，从集合的角度，可以用韦恩图形象的描述它们之间的关系： "),e("img",{src:"/yangss/assets/ts-subtype.875029f9.svg",class:"mx-auto mt-20px"})],-1),G=e("p",null,[o("我们上面都是针对对象类型使用集合的概念进行解释，如果是字面类型（literal type）以及它们的联合类型，采用集合的解释会更加直观。"),e("code",null,"extends"),o(" 也可做为泛型的约束出现，在这种场景下，它也是子集（subset）的意思：")],-1),H=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token keyword"},"function"),o(),e("span",{class:"token generic-function"},[e("span",{class:"token function"},"getKey"),e("span",{class:"token generic class-name"},[e("span",{class:"token operator"},"<"),e("span",{class:"token constant"},"K"),o(),e("span",{class:"token keyword"},"extends"),o(),e("span",{class:"token builtin"},"string"),e("span",{class:"token operator"},">")])]),e("span",{class:"token punctuation"},"("),o("val"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token builtin"},"any"),e("span",{class:"token punctuation"},","),o(" key"),e("span",{class:"token operator"},":"),o(),e("span",{class:"token constant"},"K"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token punctuation"},"{"),o("\n  "),e("span",{class:"token comment"},"// ..."),o("\n"),e("span",{class:"token punctuation"},"}"),o("\n")])])],-1),J=e("p",null,[o("这里的 "),e("code",null,"extends string"),o(" 是什么意思？如果你从对象继承的角度来思考，那就很难解释，而如果从集合的角度来考虑，就很清楚了："),e("code",null,"K"),o(" 代表的集合必须是 "),e("code",null,"string"),o(" 的子集。这包括字符串字面类型（string literal type）、字符串字面类型的联合类型（union of string literal types）和 "),e("code",null,"string"),o(" 本身。")],-1),Q=e("div",{class:"language-ts"},[e("pre",null,[e("code",null,[e("span",{class:"token function"},"getKey"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},","),o(),e("span",{class:"token string"},"'x'"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token comment"},"// OK, 'x' extends string"),o("\n"),e("span",{class:"token function"},"getKey"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},","),o(" Math"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"random"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token operator"},"<"),o(),e("span",{class:"token number"},"0.5"),o(),e("span",{class:"token operator"},"?"),o(),e("span",{class:"token string"},"'a'"),o(),e("span",{class:"token operator"},":"),o(),e("span",{class:"token string"},"'b'"),e("span",{class:"token punctuation"},")"),o(),e("span",{class:"token comment"},"// OK, 'a'|'b' extends string"),o("\n"),e("span",{class:"token function"},"getKey"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},","),o(" document"),e("span",{class:"token punctuation"},"."),o("title"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(),e("span",{class:"token comment"},"// OK, string extends string"),o("\n"),e("span",{class:"token function"},"getKey"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},"{"),e("span",{class:"token punctuation"},"}"),e("span",{class:"token punctuation"},","),o(),e("span",{class:"token number"},"12"),e("span",{class:"token punctuation"},")"),o("\n "),e("span",{class:"token comment"},"// ~~ Type '12' is not assignable to parameter of type 'string'"),o("\n")])])],-1),W=e("p",null,"如果把类型看作值的集合，这意味着具有相同值集合的两个类型是相同的。实际上就是这样，除非两个类型在语义上是不同的，只是碰巧有相同的值集合，否则没有理由将同一个类型定义两次。",-1),X=e("p",null,"最后，值得注意的是，并非所有的值集都有对应的 TypeScript 类型。所有整数组成的集合就没有对应的 TypeScript 类型，所有只包含 x 和 y 属性的对象组成的集合，也找不到对应的 TypeScript 类型。",-1),Y=e("p",null,"TypeScript 中的术语与集合论中的术语的有如下对应关系：",-1),Z=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"TypeScript term"),e("th",null,"Set term")])]),e("tbody",null,[e("tr",null,[e("td",null,"never"),e("td",null,"∅ (empty set)")]),e("tr",null,[e("td",null,"Literal type"),e("td",null,"Single element set")]),e("tr",null,[e("td",null,"Value assignable to T"),e("td",null,"Value ∈ T (member of)")]),e("tr",null,[e("td",null,"T1 assignable to T2"),e("td",null,"T1 ⊆ T2 (subset of)")]),e("tr",null,[e("td",null,"T1 extends T2"),e("td",null,"T1 ⊆ T2 (subset of)")]),e("tr",null,[e("td",null,"T1 | T2"),e("td",null,"T1 ∪ T2 (union)")]),e("tr",null,[e("td",null,"T1 & T2"),e("td",null,"T1 ∩ T2 (intersection)")]),e("tr",null,[e("td",null,"unknown"),e("td",null,"Universal set")])])],-1),$=e("h2",{id:"总结",tabindex:"-1"},[o("总结 "),e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#")],-1),nn=e("ul",null,[e("li",null,"把类型看作是类型的集合，这些集合可以是有限集（boolean，literal types）或者是无限集（number，string）。"),e("li",null,"请记住，一个对象仍然可以属于一个类型，即使它有在类型声明中没有提到的额外属性。"),e("li",null,"理解类型操作是作用在类型代表的集合上的。"),e("li",null,"把 ”extends“，“assignable to”，“subtype of” 看作是 ”subset of“（子集）的同义词。")],-1);var sn=n(p,[["render",function(n,e,o,c,p,sn){const an=s("PubDate");return l(),a("div",null,[u,t(an,{date:"2021/03/06"}),r,k,i,d,y,m,g,b,f,w,h,T,v,A,S,x,B,P,D,K,L,V,O,M,j,U,z,C,E,I,N,R,_,q,F,G,H,J,Q,W,X,Y,Z,$,nn])}]]);export{c as __pageData,sn as default};
