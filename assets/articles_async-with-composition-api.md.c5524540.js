import{o as n,c as s,a}from"./app.f91fd4f2.js";const t='{"title":"Async with Composition API","description":"","frontmatter":{},"headers":[{"level":2,"title":"一个例子","slug":"一个例子"},{"level":2,"title":"背后机制","slug":"背后机制"},{"level":3,"title":"异步 setup 的局限","slug":"异步-setup-的局限"}],"relativePath":"articles/async-with-composition-api.md","lastUpdated":1630512755791}',o={},p=[a('<h1 id="async-with-composition-api"><a class="header-anchor" href="#async-with-composition-api" aria-hidden="true">#</a> Async with Composition API</h1><p><code>setup</code> 是 Vue 3 新增的一个组件选项 (component option)，它作为 Composition API 的入口函数，极大地优化了 Vue 代码的组织方式，让代码逻辑复用变得异常容易。而异步的 <code>setup</code> (async setup) 可以让你在组件创建之前就进行异步操作，比如从服务器获取资源和数据，但是有一些坑需要引起注意。</p><h2 id="一个例子"><a class="header-anchor" href="#一个例子" aria-hidden="true">#</a> 一个例子</h2><p>先看一个例子：</p><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n    <span class="token function">watch</span><span class="token punctuation">(</span>counter<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n    <span class="token comment">// OK!</span>\n    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Mounted&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n    <span class="token comment">// the await statement</span>\n    <span class="token keyword">await</span> <span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &lt;-----------</span>\n\n    <span class="token comment">// does NOT work!</span>\n    <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Unmounted&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n    <span class="token comment">// still works, but does not auto-dispose</span>\n    <span class="token comment">// after the component is destroyed (memory leak!)</span>\n    <span class="token function">watch</span><span class="token punctuation">(</span>counter<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>value <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>在 <strong>await</strong> statement 之后执行以下 composition API，很有可能会出现问题， 因为它们不会自动 dispose:</p><ul><li><code>watch</code> / <code>watchEffect</code></li><li><code>computed</code></li><li><code>effect</code></li></ul><p>甚至下面的这些方法将不会工作：</p><ul><li><code>onMounted</code> / <code>onUnmounted</code> / <code>onXXX</code></li><li><code>provide</code> / <code>inject</code></li><li><code>getCurrentInstance</code></li><li>...</li></ul><h2 id="背后机制"><a class="header-anchor" href="#背后机制" aria-hidden="true">#</a> 背后机制</h2><p>让我们以 <code>onMounted</code> API为例。正如我们所知，<code>onMounted</code> 是一个钩子函数（hook），在当前组件被挂载（mounted）时，执行注册的 listener。请注意，<code>onMounted</code>（以及其它的组合API）是全局的，这里所说的&quot;全局&quot; 是指它可以被导入并在任何地方被调用——没有本地的上下文与它绑定。</p><div class="language-js"><pre><code><span class="token comment">// local: `onMounted` 是组件实例的方法，绑定到组件上下文</span>\ncomponent<span class="token punctuation">.</span><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>\n\n<span class="token comment">// global: `onMounted` 没有绑定上下文</span>\n<span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>\n</code></pre></div><p>那么，<code>onMounted</code> 是如何知道什么组件被挂载的呢？ Vue 采取了一个有趣的方法来解决这个问题。它使用一个内部变量来记录当前组件的实例。当 Vue 挂载一个组件时，它将该实例存储在一个全局变量中。当钩子在 setup 函数中被调用时，它将使用全局变量来获取当前组件的实例。下面是简化的代码：</p><div class="language-js"><pre><code><span class="token keyword">let</span> currentInstance <span class="token operator">=</span> <span class="token keyword">null</span>\n\n<span class="token comment">// (pseudo code)</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span>\n\n  <span class="token comment">// hold the previous instance</span>\n  <span class="token keyword">const</span> prev <span class="token operator">=</span> currentInstance\n\n  <span class="token comment">// set the instance to global</span>\n  currentInstance <span class="token operator">=</span> instance\n\n  <span class="token comment">// hooks called inside the `setup()` will have</span>\n  <span class="token comment">// the `currentInstance` as the context</span>\n  component<span class="token punctuation">.</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n  <span class="token comment">// restore the previous instance</span>\n  currentInstance <span class="token operator">=</span> prev\n<span class="token punctuation">}</span>\n</code></pre></div><p>一个简化的 <code>onMounted</code> 实现可以是这样：</p><div class="language-js"><pre><code><span class="token comment">// (pseudo code)</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&quot;onMounted&quot; can&#39;t be called outside of component setup()</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// bound listener to the current instance</span>\n  currentInstance<span class="token punctuation">.</span><span class="token function">onMounted</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这样，只要在组件的 setup 里面调用 <code>onMounted</code>，就能拿到当前组件的实例。</p><h3 id="异步-setup-的局限"><a class="header-anchor" href="#异步-setup-的局限" aria-hidden="true">#</a> 异步 setup 的局限</h3><p>到目前为止还不错，这是基于 JavaScript 是单线程的这一事实。单线程的原子性确保以下语句会紧挨着执行，换句话说，你不可能在同一时间意外地修改 currentInstance</p><div class="language-js"><pre><code>currentInstance <span class="token operator">=</span> instance\ncomponent<span class="token punctuation">.</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\ncurrentInstance <span class="token operator">=</span> prev\n</code></pre></div><p>但当 setup 函数是异步的时候，情况就变了。每当 await 一个 promise 时，你可以认为引擎暂停了这里的工作，去做另一个任务。而在这个等待的时间段内，原子性会丢失，其它组件的创建将不可预测地会改变全局变量，最终导致混乱:</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n  <span class="token keyword">await</span> <span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 输出</span>\n<span class="token comment">// 3</span>\n<span class="token comment">// 1</span>\n<span class="token comment">// 4</span>\n<span class="token comment">// (awaiting)</span>\n<span class="token comment">// 2</span>\n</code></pre></div><p>异步的 setup 函数不会阻塞后面的任务, 但 setup 内的第一个 await statement 之后的代码，将在异步任务完成之后才会被执行， 这时 setup 函数已经 return，这意味着第一个 await statement 之后的代码将拿不到当前组件实例。</p>',23)];o.render=function(a,t,o,e,c,u){return n(),s("div",null,p)};export{t as __pageData,o as default};
