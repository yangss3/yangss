import{o as n,c as s,a}from"./app.26d73a11.js";const t='{"title":"Proxy 和 Reflect","description":"","frontmatter":{},"headers":[{"level":2,"title":"Proxy","slug":"proxy"},{"level":3,"title":"使用 get 钩子设置默认值","slug":"使用-get-钩子设置默认值"},{"level":3,"title":"使用 set 钩子进行验证","slug":"使用-set-钩子进行验证"},{"level":3,"title":"使用 ownKeys 和 getOwnPropertyDescriptor 进行迭代","slug":"使用-ownkeys-和-getownpropertydescriptor-进行迭代"},{"level":3,"title":"使用 deleteProperty 拦截属性删除","slug":"使用-deleteproperty-拦截属性删除"},{"level":3,"title":"使用 has 钩子拦截属性检查","slug":"使用-has-钩子拦截属性检查"},{"level":3,"title":"使用 apply 钩子代理函数调用","slug":"使用-apply-钩子代理函数调用"},{"level":2,"title":"Reflect","slug":"reflect"},{"level":3,"title":"代理一个 getter","slug":"代理一个-getter"},{"level":2,"title":"Proxy 的局限","slug":"proxy-的局限"},{"level":3,"title":"内部插槽（Internal slots）","slug":"内部插槽（internal-slots）"},{"level":3,"title":"私有字段","slug":"私有字段"},{"level":2,"title":"可取消的 Proxy","slug":"可取消的-proxy"},{"level":2,"title":"几个用例","slug":"几个用例"},{"level":3,"title":"数组负索引","slug":"数组负索引"},{"level":3,"title":"Observable","slug":"observable"}],"relativePath":"articles/proxy-reflect.md","lastUpdated":1632300754281}',p={},e=[a('<h1 id="proxy-和-reflect"><a class="header-anchor" href="#proxy-和-reflect" aria-hidden="true">#</a> Proxy 和 Reflect</h1><h2 id="proxy"><a class="header-anchor" href="#proxy" aria-hidden="true">#</a> Proxy</h2><p>一个 <code>Proxy</code> 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地将操作转发给原对象。</p><p>语法：</p><div class="language-js"><pre><code><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>\n</code></pre></div><p>其中：</p><ul><li><code>target</code> —— 是要包装的对象，可以是任何东西，包括函数</li><li><code>handler</code> —— 代理配置：带有“钩子”的对象。比如 <code>get</code> 钩子用于读取 <code>target</code> 属性，<code>set</code> 钩子写入 <code>target</code> 属性等等</li></ul><p>对 <code>proxy</code> 进行操作时，如果在 <code>handler</code> 中存在相应的钩子，则该钩子会被调用，并且 Proxy 有机会对该操作进行代理，否则将直接对 <code>target</code> 进行操作。</p><p>首先，让我们创建一个没有任何钩子的代理：</p><div class="language-js"><pre><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 空的handler对象</span>\n\nproxy<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">5</span> <span class="token comment">// 写入 Proxy 对象 (1)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>test<span class="token punctuation">)</span> <span class="token comment">// 返回 5，test属性出现在了 target 上！</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>test<span class="token punctuation">)</span> <span class="token comment">// 还是 5，我们也可以从 proxy 对象读取它 (2)</span>\n\n<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> proxy<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// 返回 test，迭代也正常工作！ (3)</span>\n</code></pre></div><p>由于没有钩子，所有对 <code>proxy</code> 的操作都直接转发给 <code>target</code>：</p><ol><li>写入操作 <code>proxy.test=</code> 会将值写入 <code>target</code></li><li>读取操作 <code>proxy.test</code> 会从 <code>target</code> 返回对应的值</li><li>迭代 <code>proxy</code> 会从 <code>target</code> 返回对应的值</li></ol><p>我们可以看到，如果没有任何钩子，<code>proxy</code> 是一个 <code>target</code> 的透明包装。</p><p><code>Proxy</code> 是一种特殊的对象。它没有自己的属性，如果 <code>handler</code> 为空，则透明地将操作转发给 <code>target</code></p><p>要激活更多功能，我们需要添加钩子来拦截操作，那我们可以用它们拦截什么？</p><p>对于对象的大多数操作，JavaScript 规范中都有一个所谓的“内部方法”，它描述了最底层的工作方式。 例如 <code>[[Get]]</code>，用于读取属性的内部方法， <code>[[Set]]</code>，用于写入属性的内部方法，等等。这些方法仅在规范中使用，我们不能直接通过方法名调用它们。Proxy 钩子会拦截这些方法的调用，对于每个内部方法，下表中都有一个钩子，用于拦截对应的操作：</p><table><thead><tr><th style="text-align:center;">内部方法</th><th style="text-align:center;">Handler 方法</th><th style="text-align:center;">何时触发</th></tr></thead><tbody><tr><td style="text-align:center;">[[Get]]</td><td style="text-align:center;">get</td><td style="text-align:center;">读取属性</td></tr><tr><td style="text-align:center;">[[Set]]</td><td style="text-align:center;">set</td><td style="text-align:center;">写入属性</td></tr><tr><td style="text-align:center;">[[HasProperty]]</td><td style="text-align:center;">has</td><td style="text-align:center;">in 运算符</td></tr><tr><td style="text-align:center;">[[Delete]]</td><td style="text-align:center;">deleteProperty</td><td style="text-align:center;">delete 操作</td></tr><tr><td style="text-align:center;">[[Call]]</td><td style="text-align:center;">apply</td><td style="text-align:center;">proxy 对象作为函数被调用</td></tr><tr><td style="text-align:center;">[[Construct]]</td><td style="text-align:center;">construct</td><td style="text-align:center;">new 操作</td></tr><tr><td style="text-align:center;">[[GetPrototypeOf]]</td><td style="text-align:center;">getPrototypeOf</td><td style="text-align:center;">Object.getPrototypeOf</td></tr><tr><td style="text-align:center;">[[SetPrototypeOf]]</td><td style="text-align:center;">setPrototypeOf</td><td style="text-align:center;">Object.setPrototypeOf</td></tr><tr><td style="text-align:center;">[[IsExtensible]]</td><td style="text-align:center;">isExtensible</td><td style="text-align:center;">Object.isExtensible</td></tr><tr><td style="text-align:center;">[[PreventExtensions]]</td><td style="text-align:center;">preventExtensions</td><td style="text-align:center;">Object.preventExtensions</td></tr><tr><td style="text-align:center;">[[DefineOwnProperty]]</td><td style="text-align:center;">defineProperty</td><td style="text-align:center;">Object.defineProperty, Object.defineProperties</td></tr><tr><td style="text-align:center;">[[GetOwnProperty]]</td><td style="text-align:center;">getOwnPropertyDescriptor</td><td style="text-align:center;">Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries</td></tr><tr><td style="text-align:center;">[[OwnPropertyKeys]]</td><td style="text-align:center;">ownKeys</td><td style="text-align:center;">Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object/keys/values/entries</td></tr></tbody></table><p>当由内部方法和钩子来完成操作时，JavaScript 强制执行某些不变式。其中大多数用于返回值：</p><ul><li><code>[[Set]]</code> 如果值已成功写入，则必须返回 <code>true</code>，否则返回 <code>false</code></li><li><code>[[Delete]]</code> 如果已成功删除该值，则必须返回 <code>true</code>，否则返回 <code>false</code></li><li>……依此类推，我们将在下面的示例中看到更多内容</li></ul><p>还有其他一些不变量，例如：</p><ul><li><code>[[GetPrototypeOf]]</code> 应用于代理对象的，必须返回与 <code>[[GetPrototypeOf]]</code> 应用于被代理对象相同的值。换句话说，读取代理对象的原型必须始终返回被代理对象的原型。</li></ul><p>钩子可以拦截这些操作，但是必须遵循这些规则。不变量确保语言功能的正确和一致的行为。完整的不变量列表请查看<a href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots" target="_blank" rel="noopener noreferrer">规范</a>。如果你不做奇怪的事情，就不会违反它们。</p><p>让我们看看实际示例中的工作原理。</p><h3 id="使用-get-钩子设置默认值"><a class="header-anchor" href="#使用-get-钩子设置默认值" aria-hidden="true">#</a> 使用 <code>get</code> 钩子设置默认值</h3><p>最常见的钩子是用于读取/写入属性。要拦截读取操作，<code>handler</code> 应该有 <code>get(target, property, receiver)</code> 方法。读取属性时触发该方法，参数如下：</p><ul><li><code>target</code> —— 是目标对象，该对象作为第一个参数传递给 <code>new Proxy</code></li><li><code>property</code> —— 目标属性名</li><li><code>receiver</code> —— 如果目标属性是一个 <code>getter</code> 访问器属性，则 <code>receiver</code> 就是本次读取属性所在的 <code>this</code> 对象。通常，这就是 <code>proxy</code> 对象本身（或者，如果我们从代理继承，则是从该代理继承的对象）。现在我们不需要此参数，稍后将对其进行详细说明。</li></ul><p>让我们用 <code>get</code> 实现对象的默认值。</p><p>通常，当人们尝试获取不存在的数组项时，他们会得到 <code>undefined</code>, 但是我们会将常规数组包装到代理中，以捕获读取操作并在没有此类属性的情况下返回 0：</p><div class="language-js"><pre><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>\n\nnumbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment">// 默认值</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span><span class="token number">123</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 0 (没有这样的元素)</span>\n</code></pre></div><p>可以看到，使用 <code>get</code> 钩子非常容易。</p><p>我们可以用 <code>Proxy</code> 来实现任何读取默认值的逻辑，想象一下，我们有一本词典，上面有单词及其翻译：</p><div class="language-js"><pre><code><span class="token keyword">const</span> dictionary <span class="token operator">=</span> <span class="token punctuation">{</span>\n  hello<span class="token operator">:</span> <span class="token string">&#39;你好&#39;</span><span class="token punctuation">,</span>\n  bye<span class="token operator">:</span> <span class="token string">&#39;再见&#39;</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 你好</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">&#39;welcome&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>\n</code></pre></div><p>现在，如果访问的单词不存在，从 <code>dictionary</code> 读取将返回 <code>undefined</code>。但实际上，返回一个未翻译单词通常比 <code>undefined</code> 要好。用 <code>Proxy</code> 可以很容易做到这一点：</p><div class="language-js"><pre><code><span class="token keyword">const</span> dictionary <span class="token operator">=</span> <span class="token punctuation">{</span>\n  hello<span class="token operator">:</span> <span class="token string">&#39;你好&#39;</span><span class="token punctuation">,</span>\n  bye<span class="token operator">:</span> <span class="token string">&#39;再见&#39;</span>\n<span class="token punctuation">}</span>\n\ndictionary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> phrase<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截读取属性操作</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>phrase <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果字典包含该短语</span>\n      <span class="token keyword">return</span> target<span class="token punctuation">[</span>phrase<span class="token punctuation">]</span> <span class="token comment">// 返回译文</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 否则返回未翻译的短语</span>\n      <span class="token keyword">return</span> phrase\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 你好</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">&#39;welcome&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// welcome 未翻译</span>\n</code></pre></div><p>请注意代理如何覆盖变量：</p><div class="language-js"><pre><code>dictionary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>\n</code></pre></div><p>代理应该在所有地方都完全替代了目标对象。目标对象被代理后，任何人都不应该再引用目标对象。否则很容易搞砸。</p><h3 id="使用-set-钩子进行验证"><a class="header-anchor" href="#使用-set-钩子进行验证" aria-hidden="true">#</a> 使用 <code>set</code> 钩子进行验证</h3><p>当写入属性时 <code>set</code> 钩子触发， 需要在 <code>handler</code> 中定义 <code>set(target, property, value, receiver)</code> 方法：</p><ul><li><code>target</code> —— 是目标对象，该对象作为第一个参数传递给 <code>new Proxy</code></li><li><code>property</code> —— 目标属性名称</li><li><code>value</code> —— 目标属性要设置的值</li><li><code>receiver</code> —— 与 <code>get</code> 钩子类似，仅与 <code>setter</code> 访问器相关</li></ul><p>假设我们想要一个专门用于存放数字的数组。如果添加了其它类型的值，则应该抛出一个错误：</p><div class="language-js"><pre><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\nnumbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">// (*)</span>\n  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截写入操作</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">==</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> val\n      <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// 不要忘记返回 true</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">// 失败时要返回 false</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nnumbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 添加成功</span>\nnumbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 添加成功</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 2</span>\nnumbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span> <span class="token comment">// TypeError （proxy 的 `set` 操作返回 false）</span>\n</code></pre></div><p>注意到 <code>Array</code> 的内建方法依然生效！ 当使用 <code>push</code> 方法添加值时，<code>length</code> 属性会自动增加。我们的代理对象 <code>Proxy</code> 不会破坏任何东西。</p><p>我们不必重写诸如 <code>push</code> 和 <code>unshift</code> 等添加元素的数组方法，因为 <code>Proxy</code> 钩子拦截的是内部方法的调用，而这些添加数组元素的方法在内部都使用 <code>[[Set]]</code> 方法。</p><h3 id="使用-ownkeys-和-getownpropertydescriptor-进行迭代"><a class="header-anchor" href="#使用-ownkeys-和-getownpropertydescriptor-进行迭代" aria-hidden="true">#</a> 使用 <code>ownKeys</code> 和 <code>getOwnPropertyDescriptor</code> 进行迭代</h3><p><code>Object.keys</code>，<code>for..in</code> 循环和大多数其他遍历对象属性的方法都使用 <code>[[OwnPropertyKeys]]</code> 内部方法（由 <code>ownKeys</code> 钩子拦截) 来获取属性列表。</p><p>这些方法在细节上有所不同：</p><ul><li><code>Object.getOwnPropertyNames(obj)</code> 返回非 <code>Symbol</code> 键</li><li><code>Object.getOwnPropertySymbols(obj)</code> 返回 <code>Symbol</code> 键</li><li><code>Object.keys/values(obj)</code> 返回带有 <code>enumerable</code> 标记的非 <code>Symbol</code> 键值对</li><li><code>for..in</code> 循环遍历所有带有 <code>enumerable</code> 标记的非 <code>Symbol</code> 键，以及原型对象的键</li></ul><p>在下面的示例中，我们使用 <code>ownKeys</code> 钩子拦截 <code>for..in</code> 对 <code>user</code> 的遍历，还使用 <code>Object.keys</code> 和 <code>Object.values</code> 来跳过以下划线 <code>_</code> 开头的属性：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n  age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>\n  _password<span class="token operator">:</span> <span class="token string">&#39;******&#39;</span>\n<span class="token punctuation">}</span>\n\nuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">startWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// &quot;ownKeys&quot; 过滤掉le _password</span>\n<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// name，age</span>\n\n<span class="token comment">// 对这些方法同样有效：</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// name, age</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// John, 30</span>\n</code></pre></div><p>如果让 <code>ownKeys</code> 钩子返回目标对象不存在的键呢？</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\nuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// nothing</span>\n</code></pre></div><p>什么都没有，这是为什么呢？</p><p>原因很简单，<code>Object.keys</code> 仅返回带有 <code>enumerable</code> 标记的属性。为了检查它，该方法会对每个属性调用 <code>[[GetOwnProperty]]</code> 来获得属性描述符。在这里，由于目标对象没有这个属性，其描述符为空，没有 <code>enumerable</code> 标记，因此它将略过该属性。</p><p>所以要想让 <code>Object.keys</code> 返回目标对象不存在的属性，我们还需要拦截 <code>[[GetOwnProperty]]</code> 内部方法（使用 <code>getOwnPropertyDescriptor</code>），对于不存在的属性，让它返回描述符 <code>enumerable: true</code>：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\nuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      <span class="token comment">//...</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>\n</code></pre></div><p>是不是很有趣？</p><h3 id="使用-deleteproperty-拦截属性删除"><a class="header-anchor" href="#使用-deleteproperty-拦截属性删除" aria-hidden="true">#</a> 使用 <code>deleteProperty</code> 拦截属性删除</h3><p>有一个普遍的约定，即下划线 <code>_</code> 前缀的属性和方法是内部的，不应从对象外部访问它们。</p><p>从技术上讲，这是可能的，我们需要这些钩子进行代理：</p><ul><li><code>get</code> —— 读取此类属性时抛出错误</li><li><code>set</code> —— 写入属性时抛出错误</li><li><code>deleteProperty</code> —— 删除属性时抛出错误</li><li><code>ownKeys</code> —— 在使用 <code>for..in</code> 和类似 <code>Object.keys</code> 的方法时排除以 <code>_</code> 开头的属性</li></ul><p>代码如下：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n  _password<span class="token operator">:</span> <span class="token string">&#39;******&#39;</span>\n<span class="token punctuation">}</span>\n\nuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//拦截读取操作</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Access denied&quot;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">const</span> value <span class="token operator">=</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value <span class="token comment">// (1)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截写入操作</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Access denied&quot;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> val\n      <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// 记得返回 true</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截属性删除</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Access denied&quot;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword">delete</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>\n      <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// 记得返回 true</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截读取属性列表</span>\n    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// “get” 不允许读取 _password</span>\n<span class="token keyword">try</span> <span class="token punctuation">{</span>\n  <span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>_password<span class="token punctuation">)</span> <span class="token comment">// Error: Access denied</span>\n<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n\n<span class="token comment">//  “set” 不允许写入 _password</span>\n<span class="token keyword">try</span> <span class="token punctuation">{</span>\n  user<span class="token punctuation">.</span>_password <span class="token operator">=</span> <span class="token string">&quot;test&quot;</span> <span class="token comment">// Error: Access denied</span>\n<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// “deleteProperty” 不允许删除 _password 属性</span>\n<span class="token keyword">try</span> <span class="token punctuation">{</span>\n  <span class="token keyword">delete</span> user<span class="token punctuation">.</span>_password <span class="token comment">// Error: Access denied</span>\n<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// “ownKeys” 过滤排除 _password</span>\n<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// name</span>\n</code></pre></div><p>请注意在 (1) 中 <code>get</code> 钩子的重要细节：</p><div class="language-js"><pre><code><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token keyword">const</span> value <span class="token operator">=</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value\n<span class="token punctuation">}</span>\n</code></pre></div><p>为什么我们需要做一个函数作用域绑定 <code>value.bind(target)</code>，原因是，虽然我们不能从外部直接访问对象内部私用属性，但是对象自带的方法却不应该受限制。例如假设，<code>user</code> 对象有个 <code>checkPassword</code> 方法：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token function">checkPassword</span><span class="token punctuation">(</span><span class="token parameter">password</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> password <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_checkPassword\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>\n</code></pre></div><p>如果不进行（1）中的作用域绑定，<code>user</code> 经行代理之后，访问 <code>user.checkPassword</code> 时，<code>checkPassword</code> 方法内部的 <code>this</code> 指向的是代理之后的对象（<code>.</code>之前的对象），这时访问 <code>this._password</code> 将会被 <code>get</code> 钩子拦截，并抛出错误。这不是我们想要的结果，我们希望对象方法能够正常访问 <code>_password</code>，所以需要在 <code>get</code> 钩子中做一下判断，如果访问的属性是一个方法（function）, 则将它的 <code>this</code> 绑定到目标对象上，这样它就可以绕过代理的拦截。</p><p>该解决方案通常可行，但并不理想，如果我们将未代理的原目标对象传给了方法，那对象方法可能会将它传递到其它地方，这样就会引起混乱：哪个是原始对象，哪个是目标对象。而且，一个对象可能会被代理多次（多个代理可能会对该对象添加不同的“调整”），产生意想不到的后果。</p><p>因此，在任何地方都不应使用这种代理。现代 Javascript 引擎原生支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" target="_blank" rel="noopener noreferrer">类私有属性</a>，以 <code>#</code> 作为前缀, 所以 <code>Proxy</code> 并不是必需的。</p><h3 id="使用-has-钩子拦截属性检查"><a class="header-anchor" href="#使用-has-钩子拦截属性检查" aria-hidden="true">#</a> 使用 <code>has</code> 钩子拦截属性检查</h3><p>用 <code>has</code> 钩子拦截 <code>in</code> 操作符，对应的钩子为 <code>has(target, property)</code>：</p><ul><li><code>target</code> —— 是目标对象，作为第一个参数传递给 <code>new Proxy</code></li><li><code>property</code> —— 属性名称</li></ul><p>假设有一个 <code>range</code> 对象, 我们想使用 <code>in</code> 操作符来检查数字是否在 <code>range</code> 范围内：</p><div class="language-js"><pre><code><span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token punctuation">{</span>\n  start<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  end<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span>\nrange <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>range<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> prop <span class="token operator">&gt;=</span> target<span class="token punctuation">.</span>start <span class="token operator">&amp;&amp;</span> prop <span class="token operator">&lt;=</span> target<span class="token punctuation">.</span>end\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token keyword">in</span> range<span class="token punctuation">)</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">50</span> <span class="token keyword">in</span> range<span class="token punctuation">)</span> <span class="token comment">// false</span>\n</code></pre></div><p>漂亮的语法糖，不是吗？而且实现起来非常简单！</p><h3 id="使用-apply-钩子代理函数调用"><a class="header-anchor" href="#使用-apply-钩子代理函数调用" aria-hidden="true">#</a> 使用 <code>apply</code> 钩子代理函数调用</h3><p><code>apply(target, thisArg, args)</code> 钩子能使代理以函数的方式被调用：</p><ul><li><code>target</code> —— 目标函数</li><li><code>thisArg</code> —— <code>this</code> 的值</li><li><code>args</code> —— 参数列表</li></ul><p>用 <code>Proxy</code> 实现延时装饰者：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> ms</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> thisArg<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">target</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\nsayHi <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//1 代理上的所有操作都转发到原始函数</span>\n\n<span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span> <span class="token comment">// Hello, John! （3秒后）</span>\n</code></pre></div><h2 id="reflect"><a class="header-anchor" href="#reflect" aria-hidden="true">#</a> Reflect</h2><p><code>Reflect</code> 是一个内置对象，可简化的创建 <code>Proxy</code></p><p>以前的内部方法，比如 <code>[[Get]]</code>，<code>[[Set]]</code> 等等都只是规范，不能直接调用。<code>Reflect</code> 对象使调用这些内部方法成为可能，它的方法是内部方法的最小包装：</p><table><thead><tr><th style="text-align:center;">操作</th><th style="text-align:center;">Reflect 调用</th><th style="text-align:center;">内部方法</th></tr></thead><tbody><tr><td style="text-align:center;">obj[prop]</td><td style="text-align:center;">Reflect.get(obj, prop)</td><td style="text-align:center;">[[Get]]</td></tr><tr><td style="text-align:center;">obj[prop] = value</td><td style="text-align:center;">Reflect.set(obj, prop, value)</td><td style="text-align:center;">[[Set]]</td></tr><tr><td style="text-align:center;">delete obj[prop]</td><td style="text-align:center;">Reflect.deleteProperty(obj, prop)</td><td style="text-align:center;">[[Delete]]</td></tr><tr><td style="text-align:center;">new F(value)</td><td style="text-align:center;">Reflect.construct(F, value)</td><td style="text-align:center;">[[Construct]]</td></tr><tr><td style="text-align:center;">...</td><td style="text-align:center;">...</td><td style="text-align:center;">...</td></tr></tbody></table><p>这是 Reflect 执行相同操作和调用的示例：</p><div class="language-js"><pre><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\nReflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// John</span>\n</code></pre></div><p>对于每个可被 <code>Proxy</code> 捕获的内部方法，<code>Reflect</code> 都有一个对应的方法进行反射（reflect），其名称和参数与 <code>Proxy</code> 钩子相同。因此，我们可以用 <code>Reflect</code> 来将操作转发到原始对象。</p><p>在下面的例子中，钩子 <code>get</code> 和 <code>set</code> 透明地将读/写操作转发到对象，并显示一条消息：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span>\n<span class="token punctuation">}</span>\n\nuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">GET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token comment">// (1)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token comment">// (2)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> name <span class="token operator">=</span> user<span class="token punctuation">.</span>name <span class="token comment">// shows &quot;GET name&quot;</span>\nuser<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Pete&quot;</span> <span class="token comment">// shows &quot;SET name=Pete&quot;</span>\n</code></pre></div><p>这里：</p><ul><li><code>Reflect.get</code> 读取一个对象属性</li><li><code>Reflect.set</code> 写入对象属性，成功返回 <code>true</code> ，否则返回 <code>false</code></li></ul><p>就是说，一切都很简单：如果钩子想要将调用转发给原始对象，则只需使用相同的参数调用 <code>Reflect.&lt;method&gt;</code> 就足够了。</p><p>在大多数情况下，我们不使用 <code>Reflect</code> 也可以完成相同的事情，例如，使用 <code>Reflect.get(target, prop, receiver)</code> 读取属性可以替换为 <code>target[prop]</code>，尽管有一些细微的差别。</p><h3 id="代理一个-getter"><a class="header-anchor" href="#代理一个-getter" aria-hidden="true">#</a> 代理一个 getter</h3><p>让我们看一个示例，说明为什么 <code>Reflect.get</code> 更好。我们还将看到为什么 <code>get/set</code> 有第四个参数 <code>receiver</code>，而我们以前没有使用过它。</p><p>我们有一个带有一个 <code>_name</code> 属性和一个 <code>getter</code> 的对象 <code>user</code> 对象：</p><div class="language-js"><pre><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  _name<span class="token operator">:</span> <span class="token string">&#39;Guest&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userProxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// Guest</span>\n</code></pre></div><p>这个 <code>get</code> 钩子在这里是透明的，它返回原来的属性，不会做别的任何事情，对于我们的示例而言，这就足够了。</p><p>但是让我们将示例变得更加复杂：</p><div class="language-js"><pre><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  _name<span class="token operator">:</span> <span class="token string">&#39;Guest&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token comment">// (1) target = user</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>\n  __proto__<span class="token operator">:</span> userProxy<span class="token punctuation">,</span>\n  _name<span class="token operator">:</span> <span class="token string">&#39;Admin&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Expected: Admin</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 输出：Guest （？！？）</span>\n</code></pre></div><p>另一个对象 <code>admin</code> 从 <code>user</code> 继承后，我们可以观察到错误的行为，读取 <code>admin.name</code> 应该返回 <code>&#39;Admin&#39;</code>，而不是 <code>&#39;Guest&#39;</code>。</p><p>问题出现在（1）中：</p><ol><li>当我们读取 <code>admin.name</code>，由于 <code>admin</code> 对象自身没有对应的的属性，搜索将转到其原型上。</li><li>原型是 <code>userProxy</code></li><li>从代理读取 <code>name</code> 属性时，<code>get</code> 钩子会触发并从原始对象返回 <code>target[prop]</code></li><li>当调用 <code>target[prop]</code> 时，若 <code>prop</code> 是一个 getter，它将在 this=target 上下文中运行其代码。因此，结果是来自原始对象 <code>target</code> （即 <code>user</code>）的 <code>this._name</code></li></ol><p>为了解决这种问题，我们需要用到 <code>get</code> 钩子的第三个参数 <code>receiver</code>。它保证传递正确的 <code>this</code> 给 <code>getter</code>。那如何为 <code>getter</code> 传递上下文呢？对于常规函数，我们可以使用 <code>call/apply</code>，但这是一个 <code>getter</code>，它不能被调用的，只能被访问。</p><p><code>Reflect.get</code> 可以做到，如果我们使用它，一切都会正常运行：</p><div class="language-js"><pre><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  _name<span class="token operator">:</span> <span class="token string">&#39;Guest&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token comment">// (1) target = admin</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>\n  __proto__<span class="token operator">:</span> userProxy<span class="token punctuation">,</span>\n  _name<span class="token operator">:</span> <span class="token string">&#39;Admin&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Expected: Admin</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 输出：Admin （？！？）</span>\n</code></pre></div><p>现在 <code>receiver</code> 保留了对正确 <code>this</code> 的引用，该引用将在 (1) 行中使用 <code>Reflect.get</code> 传递给 <code>getter</code>。</p><p><code>Reflect</code> 调用的命名方式与 <code>Proxy</code> 钩子完全相同，并且接受相同的参数。因此我们可以将钩子重写得更短：</p><div class="language-js"><pre><code><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><code>Reflect</code> 提供了一种安全的方式来转发操作，确保我们不会忘记与此相关的任何内容。</p><h2 id="proxy-的局限"><a class="header-anchor" href="#proxy-的局限" aria-hidden="true">#</a> Proxy 的局限</h2><p>代理提供了一种独特的方法，可以在最底层更改或调整现有对象的行为。但是，它并不完。</p><h3 id="内部插槽（internal-slots）"><a class="header-anchor" href="#内部插槽（internal-slots）" aria-hidden="true">#</a> 内部插槽（Internal slots）</h3><p>许多内置对象，例如 <code>Map</code>, <code>Set</code>, <code>Date</code>, <code>Promise</code> 等等都使用了所谓的 “内部插槽”。它们类似于属性，但仅限于内部使用，仅用于规范目的。例如， <code>Map</code> 将项目存储在 <code>[[MapData]]</code> 中。内置方法直接访问它们，而不通过 <code>[[Get]]/[[Set]]</code> 内部方法。</p><p>这就是问题。在像这样的内置对象被代理后，代理对象没有这些内部插槽，因此内置方法将失败。</p><div class="language-js"><pre><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nproxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// Error</span>\n</code></pre></div><p>在内部，一个 <code>Map</code> 将所有数据存储在其 <code>[[MapData]]</code> 内部插槽中。代理对象没有这样的插槽。内建方法 <code>Map.prototype.set</code> 方法试图访问内部属性 <code>this.[[MapData]]</code>，但由于 this=proxy 在，而 <code>proxy</code> 中不能找到它，只能失败。</p><p>幸运的是，有一种解决方法：</p><div class="language-js"><pre><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> value <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">==</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nproxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1 (works!)</span>\n</code></pre></div><p>现在它可以正常工作，因为 <code>get</code> 钩子将函数属性（例如 <code>map.set</code>）绑定到目标对象（<code>map</code>）本身，因此，当 <code>set</code> 钩子的内部实现尝试访问 <code>this.[[MapData]]</code> 内部插槽时，它会成功。</p><h3 id="私有字段"><a class="header-anchor" href="#私有字段" aria-hidden="true">#</a> 私有字段</h3><p>类的私有字段也会发生类似的情况。</p><p>例如，<code>getName()</code> 方法访问私有的 <code>#name</code> 属性会在代理后中断：</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>\n  #name <span class="token operator">=</span> <span class="token string">&quot;Guest&quot;</span>\n\n  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#name\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\nuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Error</span>\n</code></pre></div><p>原因是专用字段是使用内部插槽实现的。JavaScript 访问它们时不使用 <code>[[Get]]/[[Set]]</code>。在调用 <code>getName()</code> 时 <code>this</code> 的值是代理后的 <code>user</code>，它没有带私有字段的插槽。</p><p>再次，使用 <code>bind</code> 方法的可以使它恢复正常：</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>\n  #name <span class="token operator">=</span> <span class="token string">&quot;Guest&quot;</span>\n\n  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#name\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\nuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> value <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">==</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Guest</span>\n</code></pre></div><p>该解决方案也有缺点：将原始对象暴露给方法，可能使其进一步传递并破坏其他代理功能。</p><h2 id="可取消的-proxy"><a class="header-anchor" href="#可取消的-proxy" aria-hidden="true">#</a> 可取消的 Proxy</h2><p>假设我们有一个资源，并且想随时关闭对该资源的访问 我们可以做的是将其包装成可撤销的代理，而没有任何钩子。这样的代理会将操作转发给对象，我们可以随时将其禁用。语法：</p><div class="language-js"><pre><code><span class="token keyword">const</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>\n</code></pre></div><p>一个例子：</p><div class="language-js"><pre><code><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>\n  data<span class="token operator">:</span> <span class="token string">&quot;Valuable data&quot;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// proxy 正常工作</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// Valuable data</span>\n\n<span class="token function">revoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// proxy 不再工作（已销毁）</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// Error</span>\n</code></pre></div><p>调用 <code>revoke()</code> 会从代理中删除对目标对象的所有内部引用，因此不再连接它们。之后可以对目标对象进行垃圾回收。</p><p>我们还可以将 <code>revoke</code> 存储在 <code>WeakMap</code> 中，以便能够通过代理对象轻松找到它：</p><div class="language-js"><pre><code><span class="token keyword">const</span> revokes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>\n  data<span class="token operator">:</span> <span class="token string">&quot;Valuable data&quot;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nrevokes<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> revoke<span class="token punctuation">)</span>\n\n<span class="token comment">// 之后...</span>\nrevoke <span class="token operator">=</span> revokes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span>\n<span class="token function">revoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// Error</span>\n</code></pre></div><p>这种方法的好处是我们不必随身携带 <code>revoke</code>。我们可以在需要时从 map 上获取它</p><p>这里使用 <code>WeakMap</code> 而不是 <code>Map</code> ，是因为 <code>WeakMap</code> 不会阻止垃圾回收。如果代理对象变得“无法访问”（例如，没有变量再引用它），则 <code>WeakMap</code> 允许将其与它的 <code>revoke</code> 对象一起从内存中删除，因为我们不再需要它了。</p><h2 id="几个用例"><a class="header-anchor" href="#几个用例" aria-hidden="true">#</a> 几个用例</h2><h3 id="数组负索引"><a class="header-anchor" href="#数组负索引" aria-hidden="true">#</a> 数组负索引</h3><p>像这样：</p><div class="language-js"><pre><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>\n\narray<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 3</span>\narray<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">// 2</span>\narray<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">// 1</span>\n</code></pre></div><p>换句话说，<code>array[-n]</code> 与 <code>array[array.length - n]</code> 相同。</p><p>用 Proxy 实现起来很简单：</p><div class="language-js"><pre><code><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>\n\narray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// prop 是 string, 需要先将它转换成 number </span>\n      prop <span class="token operator">=</span> <span class="token operator">+</span>prop <span class="token operator">+</span> target<span class="token punctuation">.</span>length\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\narray<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 3</span>\narray<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">// 2</span>\narray<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">// 1</span>\n</code></pre></div><h3 id="observable"><a class="header-anchor" href="#observable" aria-hidden="true">#</a> Observable</h3><p>实现一个使对象可观察的函数 <code>makeObservable(target)</code>：</p><div class="language-js"><pre><code><span class="token keyword">const</span> handlers <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&#39;handlers&#39;</span><span class="token punctuation">)</span>\n\n<span class="token keyword">function</span> <span class="token function">makeObservable</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//  初始化 handler 存储数组</span>\n  target<span class="token punctuation">[</span>handlers<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\n  <span class="token comment">// 存储 handler 函数到数组中以便于未来调用</span>\n  target<span class="token punctuation">.</span><span class="token function-variable function">observe</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">[</span>handlers<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 创建代理</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">let</span> success <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token comment">// 转发写入操作到目标对象</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果设置属性的时候没有报错</span>\n        <span class="token comment">// 调用所有 handler</span>\n        target<span class="token punctuation">[</span>handlers<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">handler</span> <span class="token operator">=&gt;</span> <span class="token function">handler</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n      <span class="token keyword">return</span> success\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\nuser <span class="token operator">=</span> <span class="token function">makeObservable</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>\n\nuser<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nuser<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;John&quot;</span> <span class="token comment">// SET name=John</span>\n</code></pre></div>',149)];p.render=function(a,t,p,o,c,l){return n(),s("div",null,e)};export{t as __pageData,p as default};
