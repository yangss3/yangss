import{_ as n,r as s,c as a,b as t,d as p,e as o,a as e,o as c}from"./app.04efe956.js";const u='{"title":"异步 setup","description":"","frontmatter":{},"headers":[{"level":2,"title":"一个例子","slug":"一个例子"},{"level":2,"title":"背后机制","slug":"背后机制"},{"level":2,"title":"异步 setup 的局限","slug":"异步-setup-的局限"},{"level":2,"title":"解决方案","slug":"解决方案"},{"level":3,"title":"记住并避免它","slug":"记住并避免它"},{"level":3,"title":"显式绑定组件实例","slug":"显式绑定组件实例"},{"level":3,"title":"<script setup> 编译时处理","slug":"script-setup-编译时处理"}],"relativePath":"articles/async-setup.md","lastUpdated":1642424918232}',l={},i=p("h1",{id:"异步-setup",tabindex:"-1"},[o("异步 setup "),p("a",{class:"header-anchor",href:"#异步-setup","aria-hidden":"true"},"#")],-1),k=e('<p><code>setup</code> 是 Vue 3 新增的一个组件选项，它作为 Composition API 的入口函数，极大地优化了 Vue 代码的组织方式，让代码逻辑复用变得非常简单和直观。而异步的 <code>setup</code> (async setup) 可以让你在组件创建之前进行异步操作，比如从服务器获取资源和数据，但是有一些注意事项，详情请看这里的<a href="https://github.com/vuejs/rfcs/discussions/234" target="_blank" rel="noopener noreferrer">讨论</a>。</p><h2 id="一个例子" tabindex="-1">一个例子 <a class="header-anchor" href="#一个例子" aria-hidden="true">#</a></h2><p>先看一个例子：</p><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n    <span class="token function">watch</span><span class="token punctuation">(</span>counter<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n    <span class="token comment">// OK!</span>\n    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Mounted&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n    <span class="token comment">// 等待异步任务</span>\n    <span class="token keyword">await</span> <span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n    <span class="token comment">// 下面不会正常调用!</span>\n    <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Unmounted&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n    <span class="token comment">// 可以正常工作，但是可能造成内存泄漏</span>\n    <span class="token comment">// 因为在组件被销毁后不会自动 dispose</span>\n    <span class="token function">watch</span><span class="token punctuation">(</span>counter<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>value <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>在 <strong>await</strong> statement 之后执行以下 composition API，很有可能会出现问题， 因为它们不会自动 dispose:</p><ul><li><code>watch</code> / <code>watchEffect</code></li><li><code>computed</code></li><li><code>effect</code></li></ul><p>而下面的这些方法将不会正常工作：</p><ul><li><code>onMounted</code> / <code>onUnmounted</code> / <code>onXXX</code></li><li><code>provide</code> / <code>inject</code></li><li><code>getCurrentInstance</code></li><li>...</li></ul><h2 id="背后机制" tabindex="-1">背后机制 <a class="header-anchor" href="#背后机制" aria-hidden="true">#</a></h2><p>以 <code>onMounted</code> 为例。如我们所知，<code>onMounted</code> 是一个钩子函数（hook），在当前组件被挂载（mounted）时，执行注册的 listener 函数。请注意，<code>onMounted</code>（以及其它的组合 API）是全局的，这里所说的&quot;全局&quot;是指它可以被导入到任何模块中被调用——即没有本地的上下文与它绑定。</p><div class="language-js"><pre><code><span class="token comment">// local: `onMounted` 是组件实例的方法，绑定到组件上下文</span>\ncomponent<span class="token punctuation">.</span><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>\n\n<span class="token comment">// global: `onMounted` 没有绑定上下文</span>\n<span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>\n</code></pre></div><p>那么，<code>onMounted</code> 是如何知道什么组件被挂载的呢？ Vue 使用一个内部变量来记录当前组件的实例。当 Vue 挂载一个组件时，它将该组件实例存储在一个全局变量中。当钩子在 setup 函数中被调用时，它将使用全局变量来获取当前组件的实例。下面是简化的代码：</p><div class="language-js"><pre><code><span class="token keyword">let</span> currentInstance <span class="token operator">=</span> <span class="token keyword">null</span>\n\n<span class="token comment">// (pseudo code)</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span>\n\n  <span class="token comment">// 先保存先前的实例</span>\n  <span class="token keyword">const</span> prev <span class="token operator">=</span> currentInstance\n\n  <span class="token comment">// 将当前组件实例存入全局变量</span>\n  currentInstance <span class="token operator">=</span> instance\n\n  <span class="token comment">// setup 内部的 hooks 函数被调用时将以 `currentInstance` 作为上下文</span>\n  component<span class="token punctuation">.</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n  <span class="token comment">// 恢复先前的实例</span>\n  currentInstance <span class="token operator">=</span> prev\n<span class="token punctuation">}</span>\n</code></pre></div><p>一个简化的 <code>onMounted</code> 实现可以是这样：</p><div class="language-js"><pre><code><span class="token comment">// (pseudo code)</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&quot;onMounted&quot; can&#39;t be called outside of component setup()</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 将 listener 绑定到当前组件实例</span>\n  currentInstance<span class="token punctuation">.</span><span class="token function">onMounted</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这样，只要在组件的 <code>setup</code> 里面调用 <code>onMounted</code>，就能拿到当前组件的实例。</p><h2 id="异步-setup-的局限" tabindex="-1">异步 setup 的局限 <a class="header-anchor" href="#异步-setup-的局限" aria-hidden="true">#</a></h2><p>如果 <code>setup</code> 是同步的，那一切都保持正常，这是基于 JavaScript 是单线程的这一事实。单线程的原子性确保以下语句会紧挨着执行，换句话说，你不可能在同一时间意外地修改 currentInstance：</p><div class="language-js"><pre><code>currentInstance <span class="token operator">=</span> instance\ncomponent<span class="token punctuation">.</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\ncurrentInstance <span class="token operator">=</span> prev\n</code></pre></div><p>但当 <code>setup</code> 函数是异步的时候，情况就变了。每当 await 一个 promise 时，你可以认为 JS 引擎暂停了这里的工作，去做另一个任务。而在这个等待的时间段内，原子性会丢失，其它组件的创建将不可预测地会改变全局变量，最终导致混乱:</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n  <span class="token keyword">await</span> <span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 输出</span>\n<span class="token comment">// 3</span>\n<span class="token comment">// 1</span>\n<span class="token comment">// 4</span>\n<span class="token comment">// (awaiting)</span>\n<span class="token comment">// 2</span>\n</code></pre></div><p>异步的 <code>setup</code> 函数不会阻塞后面的任务, 但 <code>setup</code> 内的第一个 await statement 之后的代码，将在异步任务完成之后才会被执行， 这时 <code>setup</code> 函数已经 return，这意味着第一个 await statement 之后的代码将拿不到当前组件实例。</p><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-hidden="true">#</a></h2><h3 id="记住并避免它" tabindex="-1">记住并避免它 <a class="header-anchor" href="#记住并避免它" aria-hidden="true">#</a></h3><p>当然，这是一个显而易见的解决方案。将所有的 effect 和 hooks 移到第一个 await statement 之前，并且记住在那之后不要再使用它们。</p><p>幸运的是，如果你使用 ESLint，可以启用 eslint-plugin-vue 中的 <code>vue/no-watch-after-await</code> 和 <code>vue/no-lifecycle-after-await</code> 规则，以便在出现错误时发出警告（默认情况下，插件预设中会启用这些规则）。</p><h3 id="显式绑定组件实例" tabindex="-1">显式绑定组件实例 <a class="header-anchor" href="#显式绑定组件实例" aria-hidden="true">#</a></h3><p>生命周期钩子（lifecycle hooks）实际上接受第二个参数来显式的绑定实例：</p><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在 await 之前先获取组件实例</span>\n    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token function">getCurrentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">await</span> <span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n    <span class="token function">onUnmounted</span><span class="token punctuation">(</span>\n      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Unmounted&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      instance <span class="token comment">// &lt;--- 手动给钩子函数绑定实例</span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>但是，缺点是此解决方案不适用于 <code>watch/watchEffect/computed/provide/inject</code>，因为它们不接受实例参数。 要使这些正常工作，可以使用 Vue 3.2 中新引入的 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md" target="_blank" rel="noopener noreferrer">effectScope API</a>：</p><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> effectScope <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在 await之前创建一个 scope, 它会将组件实例绑定到这个作用域内</span>\n    <span class="token keyword">const</span> scope <span class="token operator">=</span> <span class="token function">effectScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">someAsyncFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &lt;-----------</span>\n\n    scope<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token comment">/* Use `computed`, `watch`, etc. ... */</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="script-setup-编译时处理" tabindex="-1"><code>&lt;script setup&gt;</code> 编译时处理 <a class="header-anchor" href="#script-setup-编译时处理" aria-hidden="true">#</a></h3><p>在最近的 <code>&lt;script setup&gt;</code> 语法<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0040-script-setup.md#top-level-await" target="_blank" rel="noopener noreferrer">提案</a>中（Vue 3.2 可用），针对也这一问题进行了编译时的处理：</p><div class="language-"><pre><code>&lt;script setup&gt;\n  const post = await fetch(`/api/post/1`).then((r) =&gt; r.json())\n&lt;/script&gt;\n</code></pre></div><p>await 语句将自动编译为在 await 语句之后保留当前组件实例上下文的格式：</p><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> withAsyncContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> __temp<span class="token punctuation">,</span> __restore\n\n    <span class="token keyword">const</span> post <span class="token operator">=</span>\n      <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>__temp<span class="token punctuation">,</span> __restore<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">withAsyncContext</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>\n        <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/api/post/1</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> r<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">(</span>__temp <span class="token operator">=</span> <span class="token keyword">await</span> __temp<span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token function">__restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      __temp<span class="token punctuation">)</span>\n\n    <span class="token comment">// current instance context preserved</span>\n    <span class="token comment">// e.g. onMounted() will still work.</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">{</span> post <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre></div><p>有了它，异步函数就可以在与<code>&lt;script setup&gt;</code>一起使用时正常工作。唯一的遗憾是它在<code>&lt;script setup&gt;</code>之外无法工作。</p>',37);var r=n(l,[["render",function(n,p,o,e,u,l){const r=s("PubDate");return c(),a("div",null,[i,t(r,{date:"2021/09/21"}),k])}]]);export{u as __pageData,r as default};
