import{_ as n,r as s,c as a,b as p,d as e,e as o,a as t,o as c}from"./app.04efe956.js";const r='{"title":"TypeScript 中的超出属性检查 (Excess property checking)","description":"","frontmatter":{},"headers":[{"level":2,"title":"总结","slug":"总结"}],"relativePath":"articles/excess-property-checking-in-typescript.md","lastUpdated":1642503772633}',l={},i=e("h1",{id:"typescript-中的超出属性检查-excess-property-checking",tabindex:"-1"},[o("TypeScript 中的超出属性检查 (Excess property checking) "),e("a",{class:"header-anchor",href:"#typescript-中的超出属性检查-excess-property-checking","aria-hidden":"true"},"#")],-1),k=t('<p>当你把一个对象的字面量赋值给一个有声明类型的变量时，TypeScript 会确保它具有该类型的属性，而且没有任何未声明的的属性：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Room</span> <span class="token punctuation">{</span>\n  numDoors<span class="token operator">:</span> <span class="token builtin">number</span>\n  ceilingHeightFt<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> r<span class="token operator">:</span> Room <span class="token operator">=</span> <span class="token punctuation">{</span>\n  numDoors<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  ceilingHeightFt<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>\n  elephant<span class="token operator">:</span> <span class="token string">&#39;present&#39;</span>\n<span class="token punctuation">}</span> <span class="token comment">// ~~~ Object literal may only specify known properties, and &#39;elephant&#39; does not exist in type &#39;Room&#39;</span>\n</code></pre></div><p>但是通过引入一个中间变量，你还是可以把这个字面对象分配给 <code>Room</code> 类型：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  numDoors<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  ceilingHeightFt<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>\n  elephant<span class="token operator">:</span> <span class="token string">&#39;present&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> r<span class="token operator">:</span> Room <span class="token operator">=</span> obj <span class="token comment">// Ok</span>\n</code></pre></div><p>变量 <code>obj</code> 的类型被推断为 <code>{ numDoors: number; ceilingHeightFt: number; elephant: string }</code>，而这个类型的值集是 <code>Room</code> 类型的一个子集，所以赋值能通过类型检查。</p><p>那么这两个例子有什么不同？第一个例子中触发了一个叫做”超出属性检查”(excess property checking)的过程，它会帮你捕获结构化类型系统中很容易被漏掉的一类重要的错误。但是这个过程有它的局限性，把它和常规的可赋值检查(assignability checking)混为一谈会使我们更难建立对结构化类型的直觉。认识到超出属性检查(excess property checking)是一个独特的过程将有助于你建立一个更清晰的 TypeScript 类型系统的心智模型。</p><p>TypeScript 不仅试图标记那些会在运行时抛出异常的代码。它还试图找到那些不按你的意图执行的代码。下面是一个例子：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">{</span>\n  title<span class="token operator">:</span> <span class="token builtin">string</span>\n  darkMode<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">createWindow</span><span class="token punctuation">(</span>options<span class="token operator">:</span> Options<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>darkMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setDarkMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  title<span class="token operator">:</span> <span class="token string">&#39;Spider Solitaire&#39;</span><span class="token punctuation">,</span>\n  darkmode<span class="token operator">:</span> <span class="token boolean">true</span>\n  <span class="token comment">// ~~~~~ Object literal may only specify known properties, but</span>\n  <span class="token comment">//       &#39;darkmode&#39; does not exist in type &#39;Options&#39;.</span>\n  <span class="token comment">//       Did you mean to write &#39;darkMode&#39;?</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>这段代码在运行时阶段不会抛出任何错误。但它也不太可能是你的本意，原因正如错误提示指出的：应该是 <code>darkMode</code>（大写的 M），而不是 <code>darkmode</code>。</p><p>一个纯结构化类型检查器无法发现这种错误，因为 <code>Options</code> 类型所表示的值集范围非常宽泛：它包括所有包含 <code>title</code> 属性（且是 <code>string</code> 类型）的对象，只要这个对象不包含非布尔值的 <code>darkMode</code> 属性：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> o1<span class="token operator">:</span> Options <span class="token operator">=</span> document <span class="token comment">// Ok</span>\n<span class="token keyword">const</span> o2<span class="token operator">:</span> Options <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTMLAnchorElement</span> <span class="token comment">// Ok</span>\n</code></pre></div><p><code>document</code> 和 <code>HTMLAnchorElement</code> 的实例都有 <code>title</code> 属性，且都是字符串，所以这些赋值都可以成功。可见 <code>Options</code> 类型有多宽泛 !</p><p>超出属性检查(excess property checking)试图在不破坏类型系统的基本结构性质的情况下控制这种情况。它通过禁止对象字面量的未知属性来做到这一点（有时被称为“严格的对象字面检查”）。<code>document</code> 和 <code>new HTMLAnchorElement</code> 都不是对象字面量，所以没有触发检查。但是 <code>{ title, darkmode }</code> 是对象字面量，它会触发这个检查。</p><div class="language-ts"><pre><code><span class="token keyword">const</span> o<span class="token operator">:</span> Options <span class="token operator">=</span> <span class="token punctuation">{</span> darkmode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">&#39;Ski Free&#39;</span> <span class="token punctuation">}</span>\n <span class="token comment">// ~~~ &#39;darkmode&#39; does not exist in type &#39;Options&#39;...</span>\n</code></pre></div><p>这也就解释了为什么使用一个不带类型声明的中间变量就可以消除错误提示：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> intermediate <span class="token operator">=</span> <span class="token punctuation">{</span> darkmode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">&#39;Ski Free&#39;</span> <span class="token punctuation">}</span>\n<span class="token keyword">const</span> o<span class="token operator">:</span> Options <span class="token operator">=</span> intermediate <span class="token comment">// Ok</span>\n</code></pre></div><p>另外，如果你使用类型断言(type assertion)，也不会触发超出属性检查(excess property checking)：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> darkmode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">&#39;Ski Free&#39;</span> <span class="token punctuation">}</span> <span class="token keyword">as</span> Options <span class="token comment">// OK</span>\n</code></pre></div><p>这也是要尽可能使用类型声明而不是类型断言的理由之一。</p><p>如果你不想要这种检查，你可以使用一个 index signature 来告诉 TypeScript 你可以接受额外的属性：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">{</span>\n  darkMode<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n  <span class="token punctuation">[</span>otherOptions<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">unknown</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> o<span class="token operator">:</span> Options <span class="token operator">=</span> <span class="token punctuation">{</span> darkmode<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token comment">// OK</span>\n</code></pre></div><p>在“弱”类型（weak type，只包含可选属性的类型）上也有一个类似的检查：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">LineChartOptions</span> <span class="token punctuation">{</span>\n  logscale<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n  invertedYAxis<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n  areaChart<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> opts <span class="token operator">=</span> <span class="token punctuation">{</span> logScale<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>\n<span class="token keyword">const</span> o<span class="token operator">:</span> LineChartOptions <span class="token operator">=</span> opts\n<span class="token comment">// ~~~ Type &#39;{ logScale: boolean; }&#39; has no properties in common with type &#39;LineChartOptions&#39;</span>\n</code></pre></div><p>从结构的角度来看，<code>LineChartOptions</code> 类型应该包括几乎所有的对象。对于像这样的弱类型，TypeScript 添加了另一个检查，以确保值类型和声明类型至少有一个共同的属性。和超出属性检查(excess property checking)一样，这在捕捉错别字方面很有效，而且不是严格的结构性检查。但与超出属性检查不同，它发生在所有涉及弱类型的赋值过程中，使用中间变量并不能绕过这个检查。</p><p>超出属性检查是一种有效的方法，可以在属性名称中捕捉到错别字和其他错误。它对像 <code>Options</code> 这样包含可选字段的类型特别有用。但它的范围也非常有限：它只适用于对象字面量。认识到这个限制，并区分超出属性检查和普通的类型检查，这将有助于你建立两者的心智模型。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><ul><li>当你把一个对象的字面量分配给一个变量或把它作为一个参数传递给一个函数时，它会经过超出属性检查(excess property checking)。</li><li>超出属性检查是发现错误的有效方法，但它与 TypeScript 类型检查器通常所做的结构可分配性(structural assignability)检查不同。将这些过程混为一谈会使你更难建立可分配性的心智模型</li><li>注意超出属性检查的局限性：引入一个中间变量将绕过这些检查</li></ul>',27);var d=n(l,[["render",function(n,e,o,t,r,l){const d=s("PubDate");return c(),a("div",null,[i,p(d,{date:"2021/05/21"}),k])}]]);export{r as __pageData,d as default};
