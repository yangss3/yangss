import{_ as n,c as s,o as a,a as p}from"./app.46712d34.js";const t='{"title":"TypeScript 笔记","description":"","frontmatter":{},"headers":[{"level":2,"title":"Functions","slug":"functions"},{"level":3,"title":"Function Types (函数类型)","slug":"function-types-函数类型"},{"level":3,"title":"Inferring the types (类型推断)","slug":"inferring-the-types-类型推断"},{"level":3,"title":"Optional and Default Parameters (可选和默认参数)","slug":"optional-and-default-parameters-可选和默认参数"},{"level":3,"title":"Rest Parameters","slug":"rest-parameters"},{"level":3,"title":"this","slug":"this"},{"level":3,"title":"Overloads (重载)","slug":"overloads-重载"},{"level":2,"title":"Interfaces","slug":"interfaces"},{"level":3,"title":"Optional Properties","slug":"optional-properties"},{"level":3,"title":"Readonly Properties","slug":"readonly-properties"},{"level":3,"title":"Excess Property Checks","slug":"excess-property-checks"},{"level":3,"title":"Function Types","slug":"function-types"},{"level":3,"title":"Indexable Types","slug":"indexable-types"},{"level":3,"title":"Class Types","slug":"class-types"},{"level":3,"title":"Extending Interfaces","slug":"extending-interfaces"},{"level":3,"title":"Hybrid Types","slug":"hybrid-types"},{"level":3,"title":"Interfaces Extending Classes","slug":"interfaces-extending-classes"},{"level":2,"title":"Classes","slug":"classes"},{"level":3,"title":"Public by default","slug":"public-by-default"},{"level":3,"title":"Understanding private","slug":"understanding-private"},{"level":3,"title":"Understanding protected","slug":"understanding-protected"},{"level":3,"title":"Readonly modifier","slug":"readonly-modifier"},{"level":3,"title":"Parameter Properties","slug":"parameter-properties"},{"level":3,"title":"Accessors","slug":"accessors"},{"level":3,"title":"Static Properties","slug":"static-properties"},{"level":3,"title":"Abstract Classes","slug":"abstract-classes"},{"level":3,"title":"Using a class as an interface","slug":"using-a-class-as-an-interface"},{"level":2,"title":"Generics","slug":"generics"},{"level":3,"title":"Generic Types","slug":"generic-types"},{"level":3,"title":"Generic Classes","slug":"generic-classes"},{"level":3,"title":"Generic Constraints","slug":"generic-constraints"},{"level":2,"title":"Enums","slug":"enums"},{"level":3,"title":"Numeric enums","slug":"numeric-enums"},{"level":3,"title":"String enums","slug":"string-enums"},{"level":3,"title":"Heterogeneous enums","slug":"heterogeneous-enums"},{"level":3,"title":"Computed and constant members","slug":"computed-and-constant-members"},{"level":3,"title":"","slug":"union-enums-and-enum-member-types"},{"level":3,"title":"enums at runtime","slug":"enums-at-runtime"},{"level":3,"title":"Reverse mappings","slug":"reverse-mappings"},{"level":3,"title":"enums","slug":"const-enums"},{"level":3,"title":"Ambient enums","slug":"ambient-enums"},{"level":2,"title":"Type Inference","slug":"type-inference"},{"level":3,"title":"Basic","slug":"basic"},{"level":3,"title":"Best common type","slug":"best-common-type"},{"level":3,"title":"Contextual Typing","slug":"contextual-typing"},{"level":2,"title":"Type Compatibility","slug":"type-compatibility"},{"level":3,"title":"Introduction","slug":"introduction"},{"level":3,"title":"Functions","slug":"functions-1"},{"level":3,"title":"Enums","slug":"enums-1"},{"level":3,"title":"Classes","slug":"classes-1"},{"level":3,"title":"Generics","slug":"generics-1"},{"level":2,"title":"Advanced Types","slug":"advanced-types"},{"level":3,"title":"Intersection Types (交叉类型)","slug":"intersection-types-交叉类型"},{"level":3,"title":"Union Types (联合类型)","slug":"union-types-联合类型"},{"level":3,"title":"Type Guards and Differentiating Types","slug":"type-guards-and-differentiating-types"},{"level":3,"title":"Nullable Types","slug":"nullable-types"},{"level":3,"title":"Type Aliases (类型别名)","slug":"type-aliases-类型别名"},{"level":3,"title":"String Literal Types","slug":"string-literal-types"},{"level":3,"title":"Numeric Literal Types","slug":"numeric-literal-types"},{"level":3,"title":"Enum Member Types","slug":"enum-member-types"},{"level":3,"title":"Discriminated Unions","slug":"discriminated-unions"},{"level":3,"title":"Polymorphic  types (多态的 this 类型)","slug":"polymorphic-this-types-多态的-this-类型"},{"level":3,"title":"Index types","slug":"index-types"},{"level":3,"title":"Mapped types","slug":"mapped-types"},{"level":3,"title":"Conditional Types","slug":"conditional-types"},{"level":2,"title":"Modules","slug":"modules"},{"level":3,"title":"Export","slug":"export"},{"level":3,"title":"Import","slug":"import"},{"level":3,"title":"Default exports","slug":"default-exports"},{"level":3,"title":"export = and import = require()","slug":"export-and-import-require"}],"relativePath":"notes/typescript.md","lastUpdated":1636986867769}',o={},e=[p('<h1 id="typescript-笔记" tabindex="-1">TypeScript 笔记 <a class="header-anchor" href="#typescript-笔记" aria-hidden="true">#</a></h1><h2 id="functions" tabindex="-1">Functions <a class="header-anchor" href="#functions" aria-hidden="true">#</a></h2><h3 id="function-types-函数类型" tabindex="-1">Function Types (函数类型) <a class="header-anchor" href="#function-types-函数类型" aria-hidden="true">#</a></h3><div class="language-ts"><pre><code><span class="token comment">// Named function</span>\n<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> x <span class="token operator">+</span> y\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Anonymous function</span>\n<span class="token keyword">let</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> x <span class="token operator">+</span> y\n<span class="token punctuation">}</span>\n</code></pre></div><p>TypeScript 能够根据函数的 return statement 推断出函数的返回类型，因此很多时候在定义函数时可以省略掉 return type。</p><p><strong>函数类型</strong>分为两部分：参数类型和返回类型。在写<strong>函数类型</strong>时，参数类型和返回类型都必须写全，不能省略，即使函数没有返回值，也要用 <code>void</code> 来指定返回类型，返回类型与参数列表之间使用 <code>=&gt;</code> 分隔：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> <span class="token function-variable function">add</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function-variable function">number</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> x <span class="token operator">+</span> y\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 若省略掉 void 将导致编译错误</span>\n<span class="token keyword">let</span> <span class="token function-variable function">sayHi</span><span class="token operator">:</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function-variable function">void</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="inferring-the-types-类型推断" tabindex="-1">Inferring the types (类型推断) <a class="header-anchor" href="#inferring-the-types-类型推断" aria-hidden="true">#</a></h3><p>TypeScript 编译器能够根据赋值语句一边的类型推断出另一边的类型：</p><div class="language-ts"><pre><code><span class="token comment">// myAdd 被推断出的函数类型：(x: number, y: number) =&gt; number</span>\n<span class="token keyword">let</span> <span class="token function-variable function">myAdd</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token punctuation">}</span>\n<span class="token comment">//  参数 x, y 被推断出具有 number 类型</span>\n<span class="token keyword">let</span> <span class="token function-variable function">myAdd</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function-variable function">number</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token punctuation">}</span>\n</code></pre></div><h3 id="optional-and-default-parameters-可选和默认参数" tabindex="-1">Optional and Default Parameters (可选和默认参数) <a class="header-anchor" href="#optional-and-default-parameters-可选和默认参数" aria-hidden="true">#</a></h3><p>TypeScript 中， 默认情况下，函数定义时的参数列表中的每一个参数都是必须的，在函数调用时都不能省略，否则编译出错。但是也可以通过在参数名后面添加 <code>?</code> 符号来将其指定为可选参数，注意可选参数的右边不能有必须参数：</p><div class="language-ts"><pre><code><span class="token comment">// 如果不提供 lastName, lastName 将为 undefined</span>\n<span class="token keyword">function</span> <span class="token function">makeName</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastName<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>\n  <span class="token keyword">else</span>\n    <span class="token keyword">return</span> firstName\n<span class="token punctuation">}</span>\n\n<span class="token function">makeName</span><span class="token punctuation">(</span><span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n</code></pre></div><p>也可以在函数定义时给参数设置默认值，如果默认初始化参数在参数列表的末尾，则同可选参数一样，可以在调用时省略:</p><div class="language-ts"><pre><code><span class="token comment">// 与上面的函数共享函数类型：(fn: string, ln?: string) =&gt; string</span>\n<span class="token keyword">function</span> <span class="token function">makeName</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> lastName <span class="token operator">=</span> <span class="token string">&#39;Yang&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n\n<span class="token function">makeName</span><span class="token punctuation">(</span><span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">)</span> <span class="token comment">// Nicholas Yang</span>\n<span class="token function">makeName</span><span class="token punctuation">(</span><span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span>  <span class="token comment">// Nicholas Yang</span>\n<span class="token function">makeName</span><span class="token punctuation">(</span><span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// Nicholas John</span>\n</code></pre></div><p>与可选参数不同，默认初始化参数可以出现在必须参数之前，在这种情况下调用时不能省略该参数，如果要获取该参数的默认值，需要显示传递 <code>undefined</code>。</p><h3 id="rest-parameters" tabindex="-1">Rest Parameters <a class="header-anchor" href="#rest-parameters" aria-hidden="true">#</a></h3><p>在 TypeScript 中，可以用一个 rest parameter 来收集参数列表中未指定的所有传递过来的参数值，rest parameter 使用省略号 <code>...</code> 来指示，编译器会构建一个与 rest parameter 同名的数组在函数内部使用。rest parameter 可以看作是无穷数量的 optional parameter，当 rest parameter 没有接收到任何值时，同名数组将为空数组：</p><div class="language-ts"><pre><code><span class="token comment">// getNameStr 的 function type 为：(name: string, ...rest: string[]) =&gt; string</span>\n<span class="token keyword">function</span> <span class="token function">getNameStr</span><span class="token punctuation">(</span>name1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>restOfNames<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>restOfNames<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39; &#39;</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> nameStr <span class="token operator">=</span> <span class="token function">getNameStr</span><span class="token punctuation">(</span><span class="token string">&#39;Monica&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Rose&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Joey&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Rachael&#39;</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-hidden="true">#</a></h3><p>关于 <code>this</code> 在 TypeScript 中的用法, 以及如何让编译器捕获由于不正确使用 <code>this</code> 引发的错误，请移步<a href="http://www.typescriptlang.org/docs/handbook/functions.html" target="_blank" rel="noopener noreferrer">官方文档</a>。</p><h3 id="overloads-重载" tabindex="-1">Overloads (重载) <a class="header-anchor" href="#overloads-重载" aria-hidden="true">#</a></h3><p>所谓 overload 就是一个函数在调用时，根据传递的参数的 shape (数量以及类型) 不同，函数表现出不同的行为。 那么 TypeScript 如何对这样一类函数进行类型检查呢？答案就是，为这样的函数提供多个 function type 来作为它的一个重载列表，在该函数被调用时，编译器会使用这个重载列表去进行类型检查：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;blue&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;green&#39;</span><span class="token punctuation">]</span>\n\n<span class="token keyword">function</span> <span class="token function">pickColor</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token keyword">function</span> <span class="token function">pickColor</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token keyword">function</span> <span class="token function">pickColor</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> colors<span class="token punctuation">[</span>x<span class="token punctuation">]</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> colors<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">pickColor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// &#39;blue&#39;</span>\n<span class="token function">pickColor</span><span class="token punctuation">(</span><span class="token string">&#39;green&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// 2</span>\n</code></pre></div><p>注意上面例子中的 <code>function pickColor(x: any)</code> 片段不是重载列表的一部分， <code>pickColor</code> 函数只有两个重载，一个接受一个 <code>number</code> 参数，另一个接受一个 <code>string</code> 参数， 使用任何其它参数类型调用该函数将导致错误。</p><h2 id="interfaces" tabindex="-1"><a href="http://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="noopener noreferrer">Interfaces</a> <a class="header-anchor" href="#interfaces" aria-hidden="true">#</a></h2><p>基于<strong>值的形状</strong>(the shape of values) 的类型检查(type-checking) 是 TypeScript 的一个核心概念，而 interface 用来为这些类型(形状)名命，可以把 interface 当作是一个条款或协议(contract), 用来规范和约束项目内部的代码，或者为外部代码以及第三方库提供对接的规范。</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">printLabel</span><span class="token punctuation">(</span>labeledObj<span class="token operator">:</span> <span class="token punctuation">{</span> label<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>labeledObj<span class="token punctuation">.</span>label<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">printLabel</span><span class="token punctuation">(</span><span class="token punctuation">{</span>label<span class="token operator">:</span> <span class="token string">&#39;hello world&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>上面的函数 <code>printLabel</code> 接受一个 shape (type) 为 <code>{ label: string }</code> 的参数，我们可以使用 interface 来定义这样一个 shape，上面的例子可以改写如下：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">labeledValue</span> <span class="token punctuation">{</span>\n  label<span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">printLabel</span><span class="token punctuation">(</span>labeledObj<span class="token operator">:</span> labeledValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>labeledObj<span class="token punctuation">.</span>label<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">printLabel</span><span class="token punctuation">(</span><span class="token punctuation">{</span> label<span class="token operator">:</span> <span class="token string">&#39;Shameless&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// &#39;Shameless&#39;</span>\n<span class="token keyword">let</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span> label<span class="token operator">:</span> <span class="token string">&#39;The Walking Dead&#39;</span><span class="token punctuation">,</span> season<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span>\n<span class="token function">printLabel</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span>  <span class="token comment">// ok, &#39;The Walking Dead&#39;</span>\n<span class="token function">printLabel</span><span class="token punctuation">(</span><span class="token punctuation">{</span> label<span class="token operator">:</span> <span class="token string">&#39;Game of Thrones&#39;</span><span class="token punctuation">,</span> season<span class="token operator">:</span> <span class="token number">8</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// error</span>\n</code></pre></div><p>这里定义了一个接口 <code>labeledValue</code> 来描述 <code>printLabel</code> 函数参数的 shape，但是在函数调用的时候，我们传递给 <code>printLabel</code> 的参数不必显式的实现 <code>labeledValue</code> 接口，只要传递的参数的 shape 符合要求即可，而且编译器在执行类型检查时不关心传递进来的参数中属性的位置顺序，只要匹配定义接口中的各个属性的类型即可。</p><p>同时，从上面的例子中可以看出，如果调用函数时以变量的形式传递参数（如 <code>myObj</code>），参数中可以有额外的属性（如 <code>season: 10</code>）, 即传递的变量的 shape 可以是函数期望参数的 shape 的超集。但是如果在调用函数时直接传递对象字面量，那么传递的参数的 shape 必须与函数期望参数的 shape 完全一致（属性的顺序除外），否则会报错。</p><h3 id="optional-properties" tabindex="-1">Optional Properties <a class="header-anchor" href="#optional-properties" aria-hidden="true">#</a></h3><p>默认情况下，接口中定义的属性都是必须的(required)，例如上面例子中 <code>printLabel</code> 函数的参数 <code>labeledObj</code> 的属性 <code>label</code> 就是必须的，在调用时必须提供。但是像定义函数时指定可选参数一样，也可以在属性名后面紧跟符号 <code>?</code> 来为接口定义可选属性：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">squareConfig</span> <span class="token punctuation">{</span>\n  color<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  width<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">createSquare</span><span class="token punctuation">(</span>config<span class="token operator">:</span> squareConfig<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> area<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> newSquare <span class="token operator">=</span> <span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span> area<span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    newSquare<span class="token punctuation">.</span>color <span class="token operator">=</span> config<span class="token punctuation">.</span>color\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    newSquare<span class="token punctuation">.</span>area <span class="token operator">=</span> config<span class="token punctuation">.</span>width <span class="token operator">**</span> <span class="token number">2</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> newSquare\n<span class="token punctuation">}</span>\n\n<span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">&#39;blue&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span> width<span class="token operator">:</span> <span class="token number">12</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="readonly-properties" tabindex="-1">Readonly Properties <a class="header-anchor" href="#readonly-properties" aria-hidden="true">#</a></h3><p>可以将属性指定为 <code>readonly</code>, 这样当实现了该接口的对象被创建之后，这些属性将不能被修改：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>\n  <span class="token keyword">readonly</span> name<span class="token operator">:</span> <span class="token builtin">string</span>\n  price<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> book<span class="token operator">:</span> Product <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;Hello, JavaScript&#39;</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">12.5</span> <span class="token punctuation">}</span>\nbook<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;Hello, TypeScript&#39;</span>  <span class="token comment">// error</span>\nbook<span class="token punctuation">.</span>price <span class="token operator">=</span> <span class="token number">34</span>\n</code></pre></div><p>TypeScript 有个 <code>ReadonlyArray&lt;T&gt;</code> 类型，与 <code>Array&lt;T&gt;</code> 类型类似，但是移除了所有的 mutating method (e.g. <code>pop, push, shift, unshift, reverse</code>)，这能确保在数组创建之后，你无法再改变它：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>\n<span class="token keyword">let</span> b<span class="token operator">:</span> ReadonlyArray<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> a\nb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">22</span> <span class="token comment">// error</span>\nb<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment">// error</span>\nb<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">// error</span>\na <span class="token operator">=</span> b <span class="token comment">// error</span>\n</code></pre></div><p>从上面可以看到，你甚至不能将 <code>ReadonlyArray</code> 赋回给常规数组, 除非使用 type assertion:</p><div class="language-ts"><pre><code>a <span class="token operator">=</span> b <span class="token keyword">as</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span>\n</code></pre></div><blockquote><p>注意 <code>readonly</code> 与 <code>const</code> 的区别，<code>const</code> 针对的是变量，<code>readonly</code> 针对的是属性。</p></blockquote><h3 id="excess-property-checks" tabindex="-1">Excess Property Checks <a class="header-anchor" href="#excess-property-checks" aria-hidden="true">#</a></h3><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">SquareConfig</span> <span class="token punctuation">{</span>\n    color<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n    width<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">createSquare</span><span class="token punctuation">(</span>config<span class="token operator">:</span> SquareConfig<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> area<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> mySquare <span class="token operator">=</span> <span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span> colour<span class="token operator">:</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> width<span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>你可能认为上面的代码没问题，然而 TypeScript 会编译报错，因为当把对象字面量(Object literals)赋值给其它变量，或作为函数参数传递时，TypeScript 会进行额外的属性检查，如果对象字面量具有目标类型不具有的属性，就将导致错误。所以上面代码中最后一行的函数调用将报错，因为在目标参数类型中不存在 <code>colour</code> 属性。</p><p>当然可以简单的使用 type assertion 来避开这种类型检查：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> mySquare <span class="token operator">=</span> <span class="token function">createSquare</span><span class="token punctuation">(</span><span class="token punctuation">{</span> width<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> opacity<span class="token operator">:</span> <span class="token number">0.5</span> <span class="token punctuation">}</span> <span class="token keyword">as</span> SquareConfig<span class="token punctuation">)</span>\n</code></pre></div><p>但是更好的方法是在定义 interface 时添加一个 string index signature：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">SquareConfig</span> <span class="token punctuation">{</span>\n  color<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  width<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>\n  <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> sc<span class="token operator">:</span> SquareConfig <span class="token operator">=</span> <span class="token punctuation">{</span>color<span class="token operator">:</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span> opacity<span class="token operator">:</span> <span class="token number">0.5</span><span class="token punctuation">}</span>  <span class="token comment">// ok</span>\n</code></pre></div><p>上面的例子中，<code>SquareConfig</code> 类型的变量可以有任意数量的属性，只要不是 <code>color</code> 和 <code>width</code>, 它们的类型不重要。</p><h3 id="function-types" tabindex="-1">Function Types <a class="header-anchor" href="#function-types" aria-hidden="true">#</a></h3><p>Interface 除了能描述对象类型外，还可以用来描述函数类型，就像函数声明一样，但只需要给出参数列表和返回类型：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">SearchFunc</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> subString<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>一旦定义了这样的接口，就可以用它来指定函数类型：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> mySearch<span class="token operator">:</span> SearchFunc<span class="token punctuation">;</span>\n<span class="token function-variable function">mySearch</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> subString<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> result <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>subString<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> result <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>事实上如果赋值语句右边的函数不指定任何类型，TypeScript 也会根据左边的类型推断出右边的参数类型和返回类型，然后实施类型检查。</p><h3 id="indexable-types" tabindex="-1">Indexable Types <a class="header-anchor" href="#indexable-types" aria-hidden="true">#</a></h3><p>Interface 也可以用来描述索引类型，描述的 signature 包括两个部分，索引的类型和被索引值的类型：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">StringObj</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> myArray<span class="token operator">:</span> StringObj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;Bob&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Fred&#39;</span><span class="token punctuation">]</span>\n<span class="token keyword">let</span> myObject1<span class="token operator">:</span> StringObj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token number">3</span><span class="token operator">:</span> <span class="token string">&#39;Susan&#39;</span><span class="token punctuation">,</span>\n  <span class="token number">9</span><span class="token operator">:</span> <span class="token string">&#39;Rachael&#39;</span><span class="token punctuation">,</span>\n  <span class="token string">&#39;12&#39;</span><span class="token operator">:</span> <span class="token string">&#39;Monica&#39;</span>   <span class="token comment">// work</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> myObject2<span class="token operator">:</span> StringObj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&#39;1a&#39;</span><span class="token operator">:</span> <span class="token string">&quot;doesn&#39;t work&quot;</span> <span class="token punctuation">}</span>  <span class="token comment">// error</span>\n</code></pre></div><p>TypeScript 支持两种索引类型：<code>string</code> 和 <code>number</code>, 可以在一个接口中同时定义这两种类型的索引，但是数值索引(numeric indexer)的返回类型必须是字符串索引(string indexer)的返回类型的子类型(subtype)，这是因为在 JavaScript 中，通过索引访问对象时，数值索引实质上是被转换成了字符串索引的，所以数值索引的返回类型必须与字符串索引的返回类型兼容：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n    breed<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Error: indexing with a numeric string might get you a completely separate type of Animal!</span>\n<span class="token keyword">interface</span> <span class="token class-name">NotOkay</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">[</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> Animal<span class="token punctuation">;</span>\n    <span class="token punctuation">[</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> Dog<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>如果接口中定义了字符串索引，这将迫使整个类型的所有属性都必须返回与字符串索引的返回类型匹配的类型，否者不能通过类型检查：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">numberDictionary</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token comment">// 这里确定了所有其它属性的返回类型都必须是 number</span>\n  length<span class="token operator">:</span> <span class="token builtin">number</span>  <span class="token comment">// ok</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span>  <span class="token comment">// error</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="class-types" tabindex="-1">Class Types <a class="header-anchor" href="#class-types" aria-hidden="true">#</a></h3><p>interface 最常见的用处是为类(class)提供一个需要遵守的协议(contract)，如果一个类要实现某个接口，那么它必须实现这个接口定义的所有内容(属性和方法，包括继承链上的):</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">clockInterface</span> <span class="token punctuation">{</span>\n  currentTime<span class="token operator">:</span> Date\n  <span class="token function">setTime</span><span class="token punctuation">(</span>d<span class="token operator">:</span> Date<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Clock</span> <span class="token keyword">implements</span> <span class="token class-name">clockInterface</span> <span class="token punctuation">{</span>\n  currentTime<span class="token operator">:</span> Date\n  <span class="token function">constructor</span><span class="token punctuation">(</span>h<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> m<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">//...</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">setTime</span><span class="token punctuation">(</span>d<span class="token operator">:</span> Date<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>currentTime <span class="token operator">=</span> d\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>注意接口只能描述一个类的公有部分(public)：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">clockInterface</span> <span class="token punctuation">{</span>\n  currentTime<span class="token operator">:</span> Date\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">Clock</span> <span class="token keyword">implements</span> <span class="token class-name">clockInterface</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> currentTime<span class="token operator">:</span> Date  <span class="token comment">// error</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>当使用类和接口时，注意到，一个类描述了两部分：静态部分(static side)和实例部分(instance side)，如果你定义了一个用来描述构造函数的接口，然后试图创建一个类来实现这个接口，你将会失败。This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check. 更多细节看官方文档。</p><h3 id="extending-interfaces" tabindex="-1">Extending Interfaces <a class="header-anchor" href="#extending-interfaces" aria-hidden="true">#</a></h3><p>像类的继承一样，接口也可以进行扩展，这允许你将某一个接口中的成员复制到另一个接口中，让你在将接口分割成可重用的组件时有更高的灵活性。扩展接口使用 <code>extends</code> 关键字：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>\n  color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Property</span> <span class="token punctuation">{</span>\n  sideLength<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>\n  area<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 一个接口可以扩展多个接口</span>\n<span class="token keyword">interface</span> <span class="token class-name">anotherSquare</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span><span class="token punctuation">,</span> Property <span class="token punctuation">{</span>\n  area<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> square <span class="token operator">=</span> <span class="token operator">&lt;</span>Square<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\nsquare<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&#39;blue&#39;</span>\nsquare<span class="token punctuation">.</span>area <span class="token operator">=</span> <span class="token number">100</span>\n\n<span class="token keyword">let</span> anotherSq <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> anotherSquare\nanotherSq<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&#39;red&#39;</span>\nanotherSq<span class="token punctuation">.</span>sideLength <span class="token operator">=</span> <span class="token number">10</span>\nanotherSq<span class="token punctuation">.</span>area <span class="token operator">=</span> anotherSq<span class="token punctuation">.</span>sideLength <span class="token operator">**</span> <span class="token number">2</span>\n</code></pre></div><h3 id="hybrid-types" tabindex="-1">Hybrid Types <a class="header-anchor" href="#hybrid-types" aria-hidden="true">#</a></h3><p>One such example is an object that acts as both a function and an object, with additional properties:</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span>start<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>\n  interval<span class="token operator">:</span> <span class="token builtin">number</span>\n  <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Counter <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token operator">&lt;</span>Counter<span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token punctuation">(</span>start<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  counter<span class="token punctuation">.</span>interval <span class="token operator">=</span> <span class="token number">10</span>\n  counter<span class="token punctuation">.</span><span class="token function-variable function">reset</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token keyword">return</span> counter\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="interfaces-extending-classes" tabindex="-1">Interfaces Extending Classes <a class="header-anchor" href="#interfaces-extending-classes" aria-hidden="true">#</a></h3><p>接口也可以 extends 类，当接口扩展一个类时，它继承这个类的所有成员(包括私有和公有部分)，但不包含成员的实现(implementations)，就好比声明了一个拥有这个类所有成员的接口。</p><ul><li>基类只包含公有成员的情况：</li></ul><div class="language-ts"><pre><code><span class="token comment">// 基类只包含公有成员 (public member)</span>\n<span class="token keyword">class</span> <span class="token class-name">PublicBase</span> <span class="token punctuation">{</span>\n  publicState<span class="token operator">:</span> <span class="token builtin">any</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 接口继承类的所有成员</span>\n<span class="token keyword">interface</span> <span class="token class-name">PublicBaseInterface</span> <span class="token keyword">extends</span> <span class="token class-name">PublicBase</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 子类显式地实现该接口</span>\n<span class="token keyword">class</span> <span class="token class-name">SubA</span> <span class="token keyword">extends</span> <span class="token class-name">PublicBase</span> <span class="token keyword">implements</span> <span class="token class-name">PublicBaseInterface</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 子类也可以隐式的实现该接口，这里 SubB 的实例 (instance) 可以赋值给 PublicBaseInterface 类型，二者兼容</span>\n<span class="token keyword">class</span> <span class="token class-name">SubB</span> <span class="token keyword">extends</span> <span class="token class-name">PublicBase</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 如果基类只包含公有成员，非子类也可以实现该接口</span>\n<span class="token keyword">class</span> <span class="token class-name">Other</span> <span class="token keyword">implements</span> <span class="token class-name">PublicBaseInterface</span> <span class="token punctuation">{</span>\n  publicState<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> a<span class="token operator">:</span> PublicBaseInterface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token keyword">let</span> b<span class="token operator">:</span> PublicBaseInterface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token keyword">let</span> c<span class="token operator">:</span> PublicBaseInterface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n</code></pre></div><ul><li>基类包含私有成员或保护成员的情况：</li></ul><div class="language-ts"><pre><code><span class="token comment">// 基类包含私有成员 (private member)</span>\n<span class="token keyword">class</span> <span class="token class-name">PrivateBase</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> privateState<span class="token operator">:</span> <span class="token builtin">any</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 接口继承类的所有成员，包括私有成员</span>\n<span class="token keyword">interface</span> <span class="token class-name">PrivateBaseInterface</span> <span class="token keyword">extends</span> <span class="token class-name">PrivateBase</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 子类显示地实现该接口</span>\n<span class="token keyword">class</span> <span class="token class-name">SubA</span> <span class="token keyword">extends</span> <span class="token class-name">PrivateBase</span> <span class="token keyword">implements</span> <span class="token class-name">PrivateBaseInterface</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 子类也可以隐式的实现该接口，这里 SubB 的实例 (instance) 可以赋值给 PrivateBaseInterface 类型，二者兼容</span>\n<span class="token keyword">class</span> <span class="token class-name">SubB</span> <span class="token keyword">extends</span> <span class="token class-name">PrivateBase</span> <span class="token punctuation">{</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Doesn&#39;t work，如果基类包含私有成员或保护成员(protected member)，任何其它非子类都不能实现该接口，</span>\n<span class="token comment">// 因为基类的私有成员和保护成员只能在它的后代 (descendants) 中共享。</span>\n<span class="token keyword">class</span> <span class="token class-name">Other</span> <span class="token keyword">implements</span> <span class="token class-name">PrivateBaseInterface</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> privateState<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> a<span class="token operator">:</span> PrivateBaseInterface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token keyword">let</span> b<span class="token operator">:</span> PrivateBaseInterface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n</code></pre></div><blockquote><p>总之，如果接口 I extends 类 B，那么对于任何类 O 要想 implements 接口 I， 当且仅当类 O 的私有成员和保护成员与类 B 同源。</p></blockquote><h2 id="classes" tabindex="-1">Classes <a class="header-anchor" href="#classes" aria-hidden="true">#</a></h2><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Greeter</span> <span class="token punctuation">{</span>\n  greeting<span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> message\n  <span class="token punctuation">}</span>\n  <span class="token function">greeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>greeting<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> greeter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeter</span><span class="token punctuation">(</span><span class="token string">&#39;world&#39;</span><span class="token punctuation">)</span>\ngreeter<span class="token punctuation">.</span><span class="token function">greeter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Hello, world</span>\n</code></pre></div><p>TypeScript 类的用法与 ES6 类的用法基本一致，但是增加了私有成员(private member)和保护成员(protected member)的概念。</p><h3 id="public-by-default" tabindex="-1">Public by default <a class="header-anchor" href="#public-by-default" aria-hidden="true">#</a></h3><p>默认情况下，类的成员都是公有的, 当然你也可以用关键字 public 来显式的指定公有成员：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token function">constructor</span><span class="token punctuation">(</span>theName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName<span class="token punctuation">;</span> <span class="token punctuation">}</span>\n    <span class="token keyword">public</span> <span class="token function">move</span><span class="token punctuation">(</span>distanceInMeters<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> moved </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>distanceInMeters<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">m.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><ul><li>类的公有属性可以在它的子类(subclass)中通过 <code>this</code> 来访问。</li><li>类的公有方法可以在它的子类中通过 <code>super</code> 来访问。</li></ul><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>theName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName <span class="token punctuation">}</span>\n  <span class="token function">move</span><span class="token punctuation">(</span>distanceInMeters<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> moved </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>distanceInMeters<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">m.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Snake</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  length<span class="token operator">:</span> <span class="token builtin">number</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> len<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>  <span class="token comment">// 在子类的构造函数内必须首先调用父类的构造函数</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> len\n  <span class="token punctuation">}</span>\n  <span class="token function">move</span><span class="token punctuation">(</span>distanceInMeters <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 重载父类的 move 方法</span>\n      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Slithering...&quot;</span><span class="token punctuation">)</span>\n      <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span>distanceInMeters<span class="token punctuation">)</span>  <span class="token comment">// 访问父类的公有方法</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/* 访问父类的公有属性 */ is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">m long</span><span class="token template-punctuation string">`</span></span> <span class="token comment">//</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="understanding-private" tabindex="-1">Understanding private <a class="header-anchor" href="#understanding-private" aria-hidden="true">#</a></h3><p>当类的成员被标记成 <code>private</code>, 该成员不能在该类的外部被访问：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>theName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName <span class="token punctuation">}</span>\n  <span class="token function">move</span><span class="token punctuation">(</span>distanceInMeters<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> moved </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>distanceInMeters<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">m.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;Dog&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name  <span class="token comment">// Error！, &#39;name&#39; 是私有属性，无法在 Animal 外部访问</span>\n</code></pre></div><p>TypeScript 是一种结构化的类型系统，当比较两个不同的类型时，不论这两个类型来自哪里，只要它们所有成员的类型都是兼容的，就认为这两个类型是兼容的。</p><p>然而当被比较的类型中含有 <code>private</code> 或 <code>protected</code> 成员时，情况又有所不同，这样的两个类型要兼容，除了成员本身的类型要兼容之外，它们所有同名的私有成员或保护成员都必须同源，即声明于同一个地方。</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>theName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Elephant</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>theName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span>theName<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>theName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;Jack&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> elephant <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Elephant</span><span class="token punctuation">(</span><span class="token string">&#39;Rose&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&#39;Rachael&#39;</span><span class="token punctuation">)</span>\n\nanimal <span class="token operator">=</span> elephant <span class="token comment">// Ok</span>\nanimal <span class="token operator">=</span> employee <span class="token comment">// Error, 私有成员不同源，即使有完全相同的 shape，也不兼容</span>\n</code></pre></div><ul><li>类的私有成员只在该类的内部可见，在任何继承类内部都不可见，也无法通过实例直接访问</li></ul><h3 id="understanding-protected" tabindex="-1">Understanding protected <a class="header-anchor" href="#understanding-protected" aria-hidden="true">#</a></h3><p>类的保护成员与私有成员类似，唯一的区别是保护成员在继承类内部是可以直接访问的：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>\n    <span class="token keyword">public</span> publicProp<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span>\n    <span class="token keyword">private</span> privateProp<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span>\n    <span class="token keyword">protected</span> protectedProp<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n  <span class="token function">publicMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n  <span class="token keyword">private</span> <span class="token function">privateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n  <span class="token keyword">protected</span> <span class="token function">protectedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>pub<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> pri<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> pro<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span>pub<span class="token punctuation">,</span> pri<span class="token punctuation">,</span> pro<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>publicProp <span class="token comment">// ok</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>protectedProp <span class="token comment">// ok 基类的保护成员在派生类中可见</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>privateProp <span class="token comment">// error 基类的私有成员在派生类中不可见</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">publicMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">protectedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok 基类的保护成员在派生类中可见</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">privateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error 基类的私有成员在派生类中不可见</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 在实例上只能访问公有成员，私有和保护成员都不可见</span>\n<span class="token keyword">let</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>\nsc<span class="token punctuation">.</span>privateProp <span class="token comment">// error</span>\nsc<span class="token punctuation">.</span><span class="token function">privateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error</span>\nsc<span class="token punctuation">.</span>protectedProp <span class="token comment">// error</span>\nsc<span class="token punctuation">.</span><span class="token function">protectedMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error</span>\n</code></pre></div><p>构造函数也可以被指定为 <code>protected</code>，这意味着这个类不能被实例化，但是仍然可以被继承：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">ProtectedClass</span> <span class="token punctuation">{</span>\n  <span class="token keyword">protected</span> <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ProtectedClass 类可以被继承，因为它的构造函数在子类内部可以被访问</span>\n<span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">ProtectedClass</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> pc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProtectedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Error! ProtectedClass 的构造函数是 protected，外部不可见，不能被实例化</span>\n</code></pre></div><ul><li>类的保护成员只在该类和该类的继承类中可见，无法通过实例访问。</li></ul><h3 id="readonly-modifier" tabindex="-1">Readonly modifier <a class="header-anchor" href="#readonly-modifier" aria-hidden="true">#</a></h3><p>可以用 <code>readonly</code> 关键字来声明只读属性，只读属性必须在声明时初始化，或在构造函数中初始化，一旦被初始化，它们的值就不能被修改：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">ReadonlyClass</span> <span class="token punctuation">{</span>\n  <span class="token keyword">readonly</span> prop1<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token keyword">readonly</span> prop2<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token number">1</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>theProp<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prop1 <span class="token operator">=</span> theProp <span class="token punctuation">}</span>\n  <span class="token function">changeProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>prop1 <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// Error</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>prop2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// Error</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> rc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReadonlyClass</span><span class="token punctuation">(</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>\nrc<span class="token punctuation">.</span>prop1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// Error</span>\nrc<span class="token punctuation">.</span>prop2 <span class="token operator">=</span> <span class="token string">&#39;a&#39;</span> <span class="token comment">// Error</span>\n\n</code></pre></div><h3 id="parameter-properties" tabindex="-1">Parameter Properties <a class="header-anchor" href="#parameter-properties" aria-hidden="true">#</a></h3><p>如果类中声明的属性在构造函数中只是被简单的立即初始化，可以将属性的声明放到构造函数的参数列表中，这可将声明过程和初始化过程合二为一：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">myClass</span> <span class="token punctuation">{</span>\n  prop1<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token keyword">private</span> prop2<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token keyword">protected</span> prop3<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token keyword">readonly</span> prop4<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token comment">// 属性只是简单的在构造函数中初始化</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> p2<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> p3<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> p4<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>prop1 <span class="token operator">=</span> p1\n    <span class="token keyword">this</span><span class="token punctuation">.</span>prop2 <span class="token operator">=</span> p2\n    <span class="token keyword">this</span><span class="token punctuation">.</span>prop3 <span class="token operator">=</span> p3\n    <span class="token keyword">this</span><span class="token punctuation">.</span>prop4 <span class="token operator">=</span> p4\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 上面可以简化成如下，注意，使用这种形式时，公有属性的 public 关键字不能省略</span>\n<span class="token keyword">class</span> <span class="token class-name">myClass</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>\n    <span class="token keyword">public</span> prop1<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span>\n    <span class="token keyword">private</span> prop2<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span>\n    <span class="token keyword">protected</span> prop3<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span>\n    <span class="token keyword">public</span> <span class="token keyword">readonly</span> prop4<span class="token operator">:</span> <span class="token builtin">any</span>\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="accessors" tabindex="-1">Accessors <a class="header-anchor" href="#accessors" aria-hidden="true">#</a></h3><p>TypeScript 支持以 getters/setters 方式来拦截对对象属性的访问：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> passcode <span class="token operator">=</span> <span class="token string">&quot;secret passcode&quot;</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> _fullName<span class="token operator">:</span> <span class="token builtin">string</span>\n\n  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_fullName\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">set</span> <span class="token function">fullName</span><span class="token punctuation">(</span>newName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>passcode <span class="token operator">&amp;&amp;</span> passcode <span class="token operator">===</span> <span class="token string">&quot;secret passcode&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>_fullName <span class="token operator">=</span> newName\n    <span class="token punctuation">}</span>\n    <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Error: Unauthorized update of employee!&quot;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nemployee<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">&quot;Bob Smith&quot;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>employee<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="static-properties" tabindex="-1">Static Properties <a class="header-anchor" href="#static-properties" aria-hidden="true">#</a></h3><p>静态成员只能通过类(class)来访问，不能通过实例(instance)来访问:</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Grid</span> <span class="token punctuation">{</span>\n  <span class="token keyword">static</span> origin <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>\n  <span class="token function">calculateDistanceFromOrigin</span><span class="token punctuation">(</span>point<span class="token operator">:</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> xDist <span class="token operator">=</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>x <span class="token operator">-</span> Grid<span class="token punctuation">.</span>origin<span class="token punctuation">.</span>x<span class="token punctuation">)</span>\n    <span class="token keyword">let</span> yDist <span class="token operator">=</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>y <span class="token operator">-</span> Grid<span class="token punctuation">.</span>origin<span class="token punctuation">.</span>y<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>xDist <span class="token operator">*</span> xDist <span class="token operator">+</span> yDist <span class="token operator">*</span> yDist<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scale\n  <span class="token punctuation">}</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> scale<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> grid1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Grid</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>  <span class="token comment">// 1x scale</span>\n<span class="token keyword">let</span> grid2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Grid</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span>  <span class="token comment">// 5x scale</span>\n\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>grid1<span class="token punctuation">.</span><span class="token function">calculateDistanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>grid2<span class="token punctuation">.</span><span class="token function">calculateDistanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="abstract-classes" tabindex="-1">Abstract Classes <a class="header-anchor" href="#abstract-classes" aria-hidden="true">#</a></h3><p>抽象类通常被用来继承，而不能被实例化。不同于接口，接口中不能包含成员的实现，而抽象类可以包含实现。抽象类中可以声明抽象方法，但是不能提供方法的实现，必须在其派生类中提供实现。使用 <code>abstract</code> 关键字来定义抽象类和抽象方法：</p><div class="language-ts"><pre><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token keyword">abstract</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token comment">// 必须在派生类中提供实现</span>\n  <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;roaming the earth...&quot;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;wang!&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>\n  <span class="token function">feed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error, 抽象类不能被实例化</span>\n<span class="token keyword">let</span> dog<span class="token operator">:</span> Animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\ndog<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\ndog<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// ok</span>\ndog<span class="token punctuation">.</span><span class="token function">feed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error, 抽象类中不包含 feed 方法</span>\n</code></pre></div><h3 id="using-a-class-as-an-interface" tabindex="-1">Using a class as an interface <a class="header-anchor" href="#using-a-class-as-an-interface" aria-hidden="true">#</a></h3><p>可以把类当作接口来使用：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>\n  x<span class="token operator">:</span> <span class="token builtin">number</span>\n  y<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Point3d</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>\n  z<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> point3d<span class="token operator">:</span> Point3d <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span>\n</code></pre></div><h2 id="generics" tabindex="-1">Generics <a class="header-anchor" href="#generics" aria-hidden="true">#</a></h2><p>简单的例子：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">identity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> arg\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token generic-function"><span class="token function">identity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment">// explicitly invoke  显式的传入类型参数 T =&gt; number</span>\n<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token generic-function"><span class="token function">identity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span> <span class="token comment">// explicitly invoke  显式的传入类型参数 T =&gt; string</span>\n<span class="token keyword">let</span> strArr <span class="token operator">=</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// implicitly invoke  编译器自动推断出类型 T =&gt; string[]</span>\n</code></pre></div><p>注意对于 generic function，不能在函数内部把类型参数当作某种具体的类型来使用：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">loggingIdentity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error: 无法确定 arg 是否有 length 方法，因为 T 可以是任何类型</span>\n  <span class="token keyword">return</span> arg<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="generic-types" tabindex="-1">Generic Types <a class="header-anchor" href="#generic-types" aria-hidden="true">#</a></h3><p>与普通函数类型类似，在写泛型函数类型的 signature 时要加上类型参数：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">identity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> arg\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> myIdentity1<span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token operator">=</span> identity\n\n<span class="token comment">// 也可将泛型函数类型放到接口中</span>\n<span class="token keyword">interface</span> <span class="token class-name">GenericIdentityFn</span> <span class="token punctuation">{</span>\n  <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> myIdentity2<span class="token operator">:</span> GenericIdentityFn <span class="token operator">=</span> identity\n\n<span class="token comment">// 更进一步，可以把类型参数移到接口上，使接口内的其它成员都能使用。</span>\n<span class="token comment">// 但是在使用泛型接口时，需要为类型参数指定具体的类型</span>\n<span class="token keyword">interface</span> <span class="token class-name">GenericInterface<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> myIdentity3<span class="token operator">:</span> GenericInterface<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> identity\n</code></pre></div><h3 id="generic-classes" tabindex="-1">Generic Classes <a class="header-anchor" href="#generic-classes" aria-hidden="true">#</a></h3><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">GenericNumber<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>\n  zeroValue<span class="token operator">:</span> <span class="token constant">T</span>\n  <span class="token function-variable function">add</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>zeroValue <span class="token operator">=</span> val\n    <span class="token keyword">this</span><span class="token punctuation">.</span>add <span class="token operator">=</span> fn\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> myGenericNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericNumber<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span>\n</code></pre></div><h3 id="generic-constraints" tabindex="-1">Generic Constraints <a class="header-anchor" href="#generic-constraints" aria-hidden="true">#</a></h3><p>前面说过我们不能在泛型函数内部将泛型类型参数当作某种具体的类型去使用：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">loggingIdentity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error: T doesn&#39;t have .length</span>\n  <span class="token keyword">return</span> arg<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>但是如果我们预先知道我们可能需要使用某些属性，同时又想保留函数的泛型特性，该如何做呢？可以将函数的泛型类型参数加以限制，限制为具有某些特定属性的类型：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">constraintIdentityFn</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> length<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  <span class="token comment">// 这里，编译器知道了 arg 有 length 属性，所以会通过检查</span>\n  <span class="token keyword">return</span> arg\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 或者使用一个接口来描述限制</span>\n<span class="token keyword">interface</span> <span class="token class-name">ConstraintInterface</span> <span class="token punctuation">{</span>\n  length<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">constraintIdentityFn</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> ConstraintInterface<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span>\n  <span class="token keyword">return</span> arg\n<span class="token punctuation">}</span>\n\n<span class="token function">constraintIdentityFn</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment">// Error: Number does not have a .length property</span>\n<span class="token function">constraintIdentityFn</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span> <span class="token comment">// Ok</span>\n<span class="token function">constraintIdentityFn</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> length<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// Ok</span>\n</code></pre></div><p>可以声明一个类型参数，同时让它受限于另外一个类型参数</p><div class="language-ts"><pre><code><span class="token comment">// 这里类型 K 被类型 T 的 key 限制</span>\n<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getProperty</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>\n<span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span>\n<span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// error</span>\n</code></pre></div><h2 id="enums" tabindex="-1">Enums <a class="header-anchor" href="#enums" aria-hidden="true">#</a></h2><p>枚举让我们可以定义一组名命的常量，TypeScript 支持数值和字符串枚举。</p><h3 id="numeric-enums" tabindex="-1">Numeric enums <a class="header-anchor" href="#numeric-enums" aria-hidden="true">#</a></h3><div class="language-ts"><pre><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>\n  Up<span class="token punctuation">,</span> <span class="token comment">// 默认初始化为 0，其后依次递增1</span>\n  Down<span class="token punctuation">,</span> <span class="token comment">// 1</span>\n  Left<span class="token punctuation">,</span> <span class="token comment">// 2</span>\n  Right <span class="token comment">// 3</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>\n  Up <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 初始化为1，其后依次递增1</span>\n  Down<span class="token punctuation">,</span> <span class="token comment">// 2</span>\n  Left<span class="token punctuation">,</span> <span class="token comment">// 3</span>\n  Right <span class="token comment">// 4</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>\n  Up <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>\n  Down<span class="token punctuation">,</span> <span class="token comment">// 4</span>\n  Left <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span>\n  Right <span class="token comment">// 9</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>\n  Up <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>\n  Down<span class="token punctuation">,</span> <span class="token comment">// 4</span>\n  Left <span class="token operator">=</span> Up<span class="token punctuation">,</span> <span class="token comment">// 3</span>\n  Right <span class="token comment">// 4</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>注意，数值型枚举的没有被初始化的成员要么处于第一个位置，要么紧跟在被数值常量(numeric constant)初始化过的成员或被其它常量枚举成员初始化过的成员后面。也就是说下面的例子是不允许的：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> notOK <span class="token punctuation">{</span>\n  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token function">getSomeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token constant">B</span> <span class="token comment">// error, A 没有被常量初始化，所以 B 需要一个初始化器</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>使用枚举非常简单，可以像访问对象属性一样直接访问枚举的成员:</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Response <span class="token punctuation">{</span>\n  No<span class="token punctuation">,</span>\n  Yes\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> answer<span class="token operator">:</span> Response <span class="token operator">=</span> Response<span class="token punctuation">.</span>No\n\n<span class="token keyword">function</span> <span class="token function">respond</span><span class="token punctuation">(</span>recipient<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> message<span class="token operator">:</span> Response<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token function">respond</span><span class="token punctuation">(</span><span class="token string">&#39;Princess Caroline&#39;</span><span class="token punctuation">,</span> Response<span class="token punctuation">.</span>Yes<span class="token punctuation">)</span>\n</code></pre></div><h3 id="string-enums" tabindex="-1">String enums <a class="header-anchor" href="#string-enums" aria-hidden="true">#</a></h3><p>字符串枚举的每个成员都必须被初始化，要么被常量初始化，要么被其它成员初始化：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>\n  Up <span class="token operator">=</span> <span class="token string">&#39;North&#39;</span><span class="token punctuation">,</span>\n  Down <span class="token operator">=</span> <span class="token string">&#39;South&#39;</span><span class="token punctuation">,</span>\n  Left <span class="token operator">=</span> <span class="token string">&#39;West&#39;</span><span class="token punctuation">,</span>\n  Right <span class="token operator">=</span> <span class="token string">&#39;East&#39;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="heterogeneous-enums" tabindex="-1">Heterogeneous enums <a class="header-anchor" href="#heterogeneous-enums" aria-hidden="true">#</a></h3><p>TypeScript 支持，但是不建议用这样的枚举</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> BooleanLikeHeterogeneousEnum <span class="token punctuation">{</span>\n    No <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    Yes <span class="token operator">=</span> <span class="token string">&quot;YES&quot;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="computed-and-constant-members" tabindex="-1">Computed and constant members <a class="header-anchor" href="#computed-and-constant-members" aria-hidden="true">#</a></h3><p>枚举的每个成员要么是 constant，要么是 computed。</p><p>满足以下条件之一的成员是 constant 成员：</p><ul><li>是枚举的第一个成员，且没有被初始化。此时默认为常量1</li><li>没有被初始化，但是跟在数值成员的后面。 此时默认值是前面成员的值加1</li><li>被常量枚举表达式(constant enum expression)初始化。关于常量枚举表达式，请看<a href="http://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener noreferrer">官方文档</a>。</li></ul><p>除此之外其它所有成员被认为是 computed 成员：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> myEnum <span class="token punctuation">{</span>\n  <span class="token comment">// constant members</span>\n  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// numeric literal</span>\n  <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token comment">// follow a numeric constant member</span>\n  <span class="token constant">C</span> <span class="token operator">=</span> <span class="token constant">B</span><span class="token punctuation">,</span>  <span class="token comment">// reference to previously defined constant member</span>\n  <span class="token constant">D</span> <span class="token operator">=</span> AnotherEnum<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token comment">// reference to previously defined constant member from a different enum</span>\n  <span class="token constant">E</span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">+</span> <span class="token constant">D</span><span class="token punctuation">,</span> <span class="token comment">// +, -, *, /, % ... operators with constant member as operands</span>\n\n  <span class="token comment">// computed member</span>\n  <span class="token constant">F</span> <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">.</span>length\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="union-enums-and-enum-member-types" tabindex="-1"><span id="des">Union enums and enum member types</span> <a class="header-anchor" href="#union-enums-and-enum-member-types" aria-hidden="true">#</a></h3><p>There is a special subset of constant enum member that aren&#39;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</p><ul><li>any string literal (e.g. <code>&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;</code>)</li><li>any numeric literal (e.g. <code>1, 100</code>)</li><li>a unary minus applied to any numeric literal (e.g. <code>-1, -100</code>)</li></ul><p>When all members in an enum have literal enum values, some special semantics come to play.</p><p>首先就是枚举成员也可以当作类型来使用：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> ShapeKind <span class="token punctuation">{</span> Circle<span class="token punctuation">,</span> Square <span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>\n  kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Circle\n  radius<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>\n  kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Square\n  sideLength<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> c<span class="token operator">:</span> Circle <span class="token operator">=</span> <span class="token punctuation">{</span>\n  kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Square<span class="token punctuation">,</span> <span class="token comment">// error</span>\n  radius<span class="token operator">:</span> <span class="token number">100</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这样的话，枚举本身可以看成是它的所有成员类型的一个联合类型(union type)，而 TypeScript 的类型系统可以根据这个联合类型来帮你捕捉如下代码中 bug：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span> Foo<span class="token punctuation">,</span> Bar <span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">E</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token constant">E</span><span class="token punctuation">.</span>Foo <span class="token operator">||</span> x <span class="token operator">!==</span> <span class="token constant">E</span><span class="token punctuation">.</span>Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Error, 因为编译器知道这里 if 条件将永远为 true，所以报错</span>\n    <span class="token comment">//...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="enums-at-runtime" tabindex="-1">enums at runtime <a class="header-anchor" href="#enums-at-runtime" aria-hidden="true">#</a></h3><p>在运行时阶段，枚举实际上就是一个对象(查看编译生成的 js 代码即可知)，因此下面的代码可行：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span> Foo<span class="token punctuation">,</span> Bar <span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token punctuation">{</span>Foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">return</span> obj<span class="token punctuation">.</span>Foo\n<span class="token punctuation">}</span>\n\n<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">E</span><span class="token punctuation">)</span> <span class="token comment">// Works，因为 E 有属性 &#39;Foo&#39;，且类型为 number</span>\n</code></pre></div><h3 id="reverse-mappings" tabindex="-1">Reverse mappings <a class="header-anchor" href="#reverse-mappings" aria-hidden="true">#</a></h3><p>数值型枚举可以逆向映射，从枚举值映射到枚举名：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span> Foo<span class="token punctuation">,</span> Bar <span class="token punctuation">}</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">E</span><span class="token punctuation">[</span><span class="token constant">E</span><span class="token punctuation">.</span>Foo<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// &#39;Foo&#39;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">E</span><span class="token punctuation">[</span><span class="token constant">E</span><span class="token punctuation">.</span>Bar<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// &#39;Bar&#39;</span>\n</code></pre></div><p>字符串型枚举不能逆向映射。</p><h3 id="const-enums" tabindex="-1"><i style="color:red;">const</i> enums <a class="header-anchor" href="#const-enums" aria-hidden="true">#</a></h3><p>常量枚举的成员只能使用常量枚举表达式进行初始化，与普通枚举不同，常量枚举在编译期间被完全移除，不会生成对应的 js 代码，常量枚举成员在被引用点会被直接替换成对应的值，因此，常量枚举不能有计算成员。常量枚举使用关键字 <code>const</code> 来定义：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Directions <span class="token punctuation">{</span>\n    Up<span class="token punctuation">,</span>\n    Down<span class="token punctuation">,</span>\n    Left<span class="token punctuation">,</span>\n    Right\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> directions <span class="token operator">=</span> <span class="token punctuation">[</span>Directions<span class="token punctuation">.</span>Up<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Down<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Left<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Right<span class="token punctuation">]</span>\n</code></pre></div><p>上面的代码编译后生成的 js 代码如下：</p><div class="language-ts"><pre><code><span class="token keyword">var</span> directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token comment">/* Up */</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* Down */</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment">/* Left */</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token comment">/* Right */</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="ambient-enums" tabindex="-1">Ambient enums <a class="header-anchor" href="#ambient-enums" aria-hidden="true">#</a></h3><h2 id="type-inference" tabindex="-1">Type Inference <a class="header-anchor" href="#type-inference" aria-hidden="true">#</a></h2><h3 id="basic" tabindex="-1">Basic <a class="header-anchor" href="#basic" aria-hidden="true">#</a></h3><p>在某些地方(变量初始化、对象成员初始化、函数默认参数初始化、函数返回值)如果没有显式提供类型声明，TypeScript 会进行类型推断给出类型信息：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment">// 变量 x 被推断出类型为 number</span>\n\n<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token string">&#39;default Value&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// f 的参数 a 被推断出类型为 string，返回类型被推断为 number</span>\n  <span class="token keyword">return</span> a<span class="token punctuation">.</span>length\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="best-common-type" tabindex="-1">Best common type <a class="header-anchor" href="#best-common-type" aria-hidden="true">#</a></h3><p>当类型推断需要在多个表达式中进行时，TypeScript 会在所有候选类型中选出一个最公共的类型来作为推断结果：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">]</span> <span class="token comment">// x 的类型被推断为： (number | null)[]</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">// y 的类型被推断为 (Dog | Cat)[]</span>\n<span class="token keyword">let</span> z <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">// z 的类型被推断为 Animal[]</span>\n</code></pre></div><p>为了推断 <code>x, y, z</code> 的类型，必须要考虑数组中每个元素的类型，TypeScript 会通过最优公共类型算法(the best common type algorithm)找出与其它所有类型都兼容的类型作为最终推断结果，如果不存在这样的类型，TypeScript 会将其推断为联合类型(union type)。</p><h3 id="contextual-typing" tabindex="-1">Contextual Typing <a class="header-anchor" href="#contextual-typing" aria-hidden="true">#</a></h3><div class="language-ts"><pre><code>window<span class="token punctuation">.</span><span class="token function-variable function">onmousedown</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>mouseEvent<span class="token punctuation">)</span><span class="token punctuation">{</span>\n  mouseEvent<span class="token punctuation">.</span>button <span class="token comment">// ok</span>\n  mouseEvent<span class="token punctuation">.</span>haha <span class="token comment">// error</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>TypeScript 能根据赋值运算符左边的类型推断右边的类型，上面根据 <code>window.onmousedown</code> 推断出参数 <code>mouseEvent</code> 的类型，访问不存在于 <code>mouseEvent</code> 中的属性就会报错。</p><h2 id="type-compatibility" tabindex="-1">Type Compatibility <a class="header-anchor" href="#type-compatibility" aria-hidden="true">#</a></h2><h3 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-hidden="true">#</a></h3><p>TypeScript 中的类型兼容性是基于结构子类型(structural subtyping)的，一种类型与另一种类型兼容只需要它们的各个成员都兼容即可：</p><div class="language-ts"><pre><code> <span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>\n   name<span class="token operator">:</span> <span class="token builtin">string</span>\n <span class="token punctuation">}</span>\n\n <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n   name<span class="token operator">:</span> <span class="token builtin">string</span>\n <span class="token punctuation">}</span>\n\n <span class="token keyword">let</span> p<span class="token operator">:</span> Named <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n</code></pre></div><p>TypeScript 的结构化类型系统的基本规则是：如果 <code>y</code> 具有至少与 <code>x</code> 完全相同的成员，则 <code>x</code> 与 <code>y</code> 兼容。例如：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token constant">X</span>\n<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">27</span> <span class="token punctuation">}</span> <span class="token comment">// y 的推断类型为：{name: string, age: number}</span>\nx <span class="token operator">=</span> y <span class="token comment">// ok, y 包含至少与 x 完全相同的成员</span>\n</code></pre></div><p><code>y</code> 是否能赋值给 <code>x</code>，编译器会去检查 <code>x</code> 的每一个成员是否都能在 <code>y</code> 中找到完全兼容的一个成员与之对应。</p><p>同样的赋值操作检查也发生在函数调用传参时，接着上面的例子：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">X</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment">// ok</span>\n</code></pre></div><h3 id="functions-1" tabindex="-1">Functions <a class="header-anchor" href="#functions-1" aria-hidden="true">#</a></h3><h4 id="函数参数的兼容性" tabindex="-1">函数参数的兼容性 <a class="header-anchor" href="#函数参数的兼容性" aria-hidden="true">#</a></h4><p>原始类型以及对象类型之间的兼容性是很直观的，但是两个函数的兼容性就有点复杂了。先看一个简单的例子，两个仅参数列表不相同的函数：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span>   <span class="token comment">// x 的类型被推断为 (a: number) =&gt; number</span>\n<span class="token keyword">let</span> <span class="token function-variable function">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span>  <span class="token comment">// y 的类型被推断为 (b: number, c: string) =&gt; number</span>\n\ny <span class="token operator">=</span> x <span class="token comment">// ok</span>\nx <span class="token operator">=</span> y <span class="token comment">// error</span>\n</code></pre></div><p>编译器在检查 <code>x</code> 是否能赋值给 <code>y</code> 时，首先检查函数的参数列表， <code>x</code> 的每一个参数都必须在 <code>y</code> 中有对应的与之兼容的参数(名称可以不同，但是类型和出现的位置必须相同)，才能通过检查。所以上面允许 <code>y = x</code> ，不允许 <code>x = y</code>。</p><p>这看起来好像与对象类型的兼容性检查规则正好相反，但这在 JavaScript 中是很常见的，函数可以忽略额外的函数参数，通过查看编译生成的 js 代码就容易理解了。</p><h4 id="返回类型的兼容性" tabindex="-1">返回类型的兼容性 <a class="header-anchor" href="#返回类型的兼容性" aria-hidden="true">#</a></h4><p>然后来看针对返回类型的检查，两个仅返回类型不同的两个函数：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;Alice&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// x 的类型被推断为 () =&gt; {name: string}</span>\n<span class="token keyword">let</span> <span class="token function-variable function">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">,</span> location<span class="token operator">:</span> <span class="token string">&#39;China&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// y 的类型被推断为 () =&gt; {name: string, location: string}</span>\n\nx <span class="token operator">=</span> y <span class="token comment">// ok</span>\ny <span class="token operator">=</span> x <span class="token comment">// error: x 的返回类型缺少 location 属性</span>\n</code></pre></div><p>TypeScript 要求 source function 的返回类型必须是 target function 的返回类型的子类型，赋值才被允许。</p><h4 id="function-parameter-bivariance" tabindex="-1">Function Parameter Bivariance <a class="header-anchor" href="#function-parameter-bivariance" aria-hidden="true">#</a></h4><p>前面说到，函数在赋值时进行参数类型检查，如果把函数的参数列表看作一个对象，那么目标函数的参数列表必须是源函数的参数列表的子类型，赋值才被允许。那么就会出现如下这种很常见且合理的需求，但是无法通过类型检查的情况：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> EventType <span class="token punctuation">{</span> Mouse<span class="token punctuation">,</span> KeyBoard <span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> timestamp<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>\n<span class="token keyword">interface</span> <span class="token class-name">MSEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n<span class="token keyword">interface</span> <span class="token class-name">KBEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> keyCode<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">listenEvent</span><span class="token punctuation">(</span>eventType<span class="token operator">:</span> EventType<span class="token punctuation">,</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 这里 listenEvent 的第二个参数会出现函数赋值的情况，</span>\n<span class="token comment">// 目标函数的参数列表类型可以看作为 Event，源函数的参数列表类型看作为 MSEvent，</span>\n<span class="token comment">// 因为目标参数类型不是源参数类型的子类型，所以赋值不被允许。</span>\n<span class="token comment">// 但是单从函数的调用上来看，这种需求又是合理的，因为 MSEvent 是 Event 的子类。</span>\n<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> MSEvent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>x<span class="token punctuation">,</span> e<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// error</span>\n\n<span class="token comment">// 但是可以有如下不太理想的替代方案</span>\n<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MSEvent<span class="token operator">&gt;</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>MSEvent<span class="token operator">&gt;</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token operator">:</span> MSEvent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>x<span class="token punctuation">,</span> e<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n</code></pre></div><h4 id="optional-parameters-and-rest-parameters" tabindex="-1">Optional Parameters and Rest Parameters <a class="header-anchor" href="#optional-parameters-and-rest-parameters" aria-hidden="true">#</a></h4><p>在比较函数的兼容性时，对 optional parameters 和 rest parameters 会做相同的处理，如果一个函数具有 rest parameter，会被当作为具有无限多个 optional parameter 的函数来处理：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> <span class="token function-variable function">f1</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token keyword">let</span> <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> d<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> e<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token keyword">let</span> <span class="token function-variable function">f3</span> <span class="token operator">=</span> <span class="token punctuation">(</span>g<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> h<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n\nf1 <span class="token operator">=</span> f2 <span class="token comment">// ok 源参数列表中存在额外的可选参数，可以通过检查</span>\nf2 <span class="token operator">=</span> f1 <span class="token comment">// ok 目标参数列表中存在额外的可选参数，可以通过检查</span>\nf1 <span class="token operator">=</span> f3 <span class="token comment">// error 不属于上述两种情况</span>\n</code></pre></div><p>更多细节请看<a href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener noreferrer">官方文档</a>。</p><h4 id="functions-with-overloads" tabindex="-1">Functions with Overloads <a class="header-anchor" href="#functions-with-overloads" aria-hidden="true">#</a></h4><p>When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function.</p><h3 id="enums-1" tabindex="-1">Enums <a class="header-anchor" href="#enums-1" aria-hidden="true">#</a></h3><p>枚举类型与数值类型(number)是兼容的：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span> red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue <span class="token punctuation">}</span>\n<span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token builtin">number</span>\n<span class="token keyword">let</span> b<span class="token operator">:</span> Color\na <span class="token operator">=</span> Color<span class="token punctuation">.</span>red <span class="token comment">// ok</span>\nb <span class="token operator">=</span> <span class="token number">5</span> <span class="token comment">// ok</span>\n</code></pre></div><p>但是来自不同枚举类型的枚举值之间是不兼容的：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span> red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue <span class="token punctuation">}</span>\n<span class="token keyword">enum</span> Status <span class="token punctuation">{</span> ready<span class="token punctuation">,</span> waiting <span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> c <span class="token operator">=</span> Color<span class="token punctuation">.</span>red\nc <span class="token operator">=</span> Status<span class="token punctuation">.</span>ready <span class="token comment">// error</span>\n</code></pre></div><h3 id="classes-1" tabindex="-1">Classes <a class="header-anchor" href="#classes-1" aria-hidden="true">#</a></h3><p>类的兼容性规则与对象字面量和接口的规则相似，但是有个例外，当对两个类进行比较时，仅实例成员被比较，静态成员和构造函数不影响类的兼容性：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">static</span> remark <span class="token operator">=</span> <span class="token string">&quot;I&#39;m a person&quot;</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>fn<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> ln<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> fn <span class="token operator">+</span> <span class="token string">&#39; &#39;</span> <span class="token operator">+</span> ln\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;Jack&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Yang&#39;</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 静态成员和构造函数不影响兼容性，在没有私有和保护成员的情况下，只要各共有成员都兼容，任何两个类都是兼容的</span>\na <span class="token operator">=</span> p <span class="token comment">// ok</span>\np <span class="token operator">=</span> a <span class="token comment">// ok</span>\n</code></pre></div><p>但是类的私有成员和保护成员会影响两个类的兼容型，当两个类具有私有或保护成员时，它们的实例兼容的必要条件是它们的私有和保护成员同源，即来自于同一个类的声明，否者即使二者具有完全相同的 shape，也不兼容：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">private</span> age<span class="token operator">:</span> <span class="token builtin">number</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span>\n  <span class="token keyword">private</span> age<span class="token operator">:</span> <span class="token builtin">number</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;Jack&#39;</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 虽然两个类有完全相同的shape，但是它们的私有成员来自不同的类声明，所以不兼容</span>\na <span class="token operator">=</span> p <span class="token comment">// error</span>\np <span class="token operator">=</span> a <span class="token comment">// error</span>\n</code></pre></div><h3 id="generics-1" tabindex="-1">Generics <a class="header-anchor" href="#generics-1" aria-hidden="true">#</a></h3><p>由于 TypeScript 是结构类型系统，因此泛型类型的类型参数仅在作为成员类型的一部分使用时才会影响结果类型：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Empty<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n<span class="token keyword">let</span> x<span class="token operator">:</span> Empty<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span>\n<span class="token keyword">let</span> y<span class="token operator">:</span> Empty<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span>\nx <span class="token operator">=</span> y <span class="token comment">// ok, 类型参数没有在成员中使用，不影响结果类型的兼容性</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">notEmpty<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>\n  data<span class="token operator">:</span> <span class="token constant">T</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> a<span class="token operator">:</span> notEmpty<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span>\n<span class="token keyword">let</span> b<span class="token operator">:</span> notEmpty<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span>\na <span class="token operator">=</span> b <span class="token comment">// error, 类型参数是成员类型的一部分</span>\n</code></pre></div><h2 id="advanced-types" tabindex="-1"><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="noopener noreferrer">Advanced Types</a> <a class="header-anchor" href="#advanced-types" aria-hidden="true">#</a></h2><h3 id="intersection-types-交叉类型" tabindex="-1">Intersection Types (交叉类型) <a class="header-anchor" href="#intersection-types-交叉类型" aria-hidden="true">#</a></h3><p>交叉类型就是把多个不同的类型组合成一个类型，让它拥有这些类型的所有特性，例如 <code>Person &amp; Serializable &amp; Loggable</code> 是 <code>Person</code>， <code>Serializable</code>，<code>Loggable</code> 这三种类型的交叉类型，这个交叉类型的实例将拥有这三个类型的所有成员。</p><h3 id="union-types-联合类型" tabindex="-1">Union Types (联合类型) <a class="header-anchor" href="#union-types-联合类型" aria-hidden="true">#</a></h3><p>联合类型和交叉类型很相似，但是使用方式截然不同。在 JavaScript 中我们经常有这样的需求，一个函数某个参数可以是多种不同的类型，例如下面的例子：</p><div class="language-ts"><pre><code><span class="token comment">/**\n * Takes a string and adds &quot;padding&quot; to the left.\n * If &#39;padding&#39; is a string, then &#39;padding&#39; is appended to the left side.\n * If &#39;padding&#39; is a number, then that number of spaces is added to the left side.\n */</span>\n<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected string or number, got &#39;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&#39;.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;    Hello world&quot;</span>\n<span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token string">&#39;Nicholas, &#39;</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Nicholas, Hello world&quot;</span>\n<span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// passes at compile time, fails at runtime.</span>\n</code></pre></div><p>在提到联合类型之前只能像这样实现，这也是 JavaScript 中的解决方式，但是有一个问题是参数 <code>padding</code> 的类型是 <code>any</code>，意味着这个 <code>padding</code> 参数可以接受任何类型的值，而不仅仅是 <code>string</code> 和 <code>number</code>，这与 TypeScript 类型控制的灵魂背道而驰，解决办法就是使用联合类型：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token string">&#39;Nicholas, &#39;</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// error, fails at compile time</span>\n</code></pre></div><p>联合类型的意思是这个类型的实例可以是多种类型之一，每个类型用符号 <code>|</code> 分隔，例如 <code>string | number| boolean</code> 是 <code>string</code>，<code>number</code> 和 <code>boolean</code> 的一个联合类型。</p><p>如果一个变量是联合类型，我们只能通过这个变量访问这个联合的所有类型的共有部分：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Fish</span> <span class="token punctuation">{</span>\n  <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n  <span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>\n  <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n  <span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Fish <span class="token operator">|</span> Bird <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\npet<span class="token punctuation">.</span><span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\npet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error</span>\npet<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error</span>\n</code></pre></div><h3 id="type-guards-and-differentiating-types" tabindex="-1">Type Guards and Differentiating Types <a class="header-anchor" href="#type-guards-and-differentiating-types" aria-hidden="true">#</a></h3><p>如上面例子看到的那样，<code>getSmallPet</code> 虽然返回一个 <code>Fish</code> 和 <code>Bird</code> 的联合类型，但是我们只能访问这两个类型共有的成员 <code>layEggs</code>，即使在运行时阶段(runtime)可以确定返回类型为 <code>Fish</code>，但是 <code>pet.swim()</code> 依然无法通过编译检查。这使得联合类型在某些时候显得有点 tricky，不过也有应对办法，最简单直观的就是使用类型断言(type assertion):</p><div class="language-ts"><pre><code><span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Fish<span class="token operator">&gt;</span>pet<span class="token punctuation">)</span><span class="token punctuation">.</span>swim<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span><span class="token operator">&lt;</span>Fish<span class="token operator">&gt;</span>pet<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span><span class="token operator">&lt;</span>Bird<span class="token operator">&gt;</span>pet<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>上面的方法虽然可行，但是不够简洁，我们需要进行多次类型断言，一个更好的解决方案是使用类型守卫(type guards).</p><h4 id="user-defined-type-guards" tabindex="-1">User-Defined Type Guards <a class="header-anchor" href="#user-defined-type-guards" aria-hidden="true">#</a></h4><p>一个 type guard 是一个表达式，这个表达式用来执行运行时类型检查。要定义一个 type guard，只需要定义一个返回类型为类型谓词(type predicate)的函数即可：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token operator">:</span> Fish<span class="token operator">|</span>Bird<span class="token punctuation">)</span><span class="token operator">:</span> pet <span class="token keyword">is</span> Fish <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>Fish<span class="token operator">&gt;</span>pet<span class="token punctuation">)</span><span class="token punctuation">.</span>swim <span class="token operator">!==</span> <span class="token keyword">undefined</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这里的 <code>pet is Fish</code> 就是类型谓词(type predicate)，类型谓词遵循 <code>parameterName is Type</code> 这样的形式，其中 <code>parameterName</code> 必须是来自当前函数参数列表的参数名。任何时候，只要 <code>isFish</code> 在某个兼容的变量上调用，TypeScript 就会将这个变量的类型缩窄到具体的类型：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  pet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  pet<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>可以看到，通过 type guard 之后，TypeScript 不仅知道在 <code>if</code> 分支，<code>pet</code> 的类型是 <code>Fish</code>，而且也知道在 <code>else</code> 分支，<code>pet</code> 的类型是 <code>Bird</code>。</p><h4 id="typeof-type-guards" tabindex="-1"><span style="color:red;">typeof</span> type guards <a class="header-anchor" href="#typeof-type-guards" aria-hidden="true">#</a></h4><p>我们回到前面 <code>padLeft</code> 函数的例子，可以定义两个 user-defined type guard 来将其改写为：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">isNumber</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> Number <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> String <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNumber</span><span class="token punctuation">(</span>padding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>padding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected string or number, got &#39;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&#39;.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>然而必须定义一个函数来确定一个类型是否为原始类型(primitive)是很痛苦的，幸运的是，TypeScript 可以将 <code>typeof x === &#39;number&#39;</code> 这样的语句直接视为 <span style="color:red;">typeof</span> type guard，而不必将 <code>typeof x === &#39;number&#39;</code> 封装到 user-defined type guard 中。这意味着下面的代码就已经包含了 type guard：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// typeof type guard</span>\n        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// typeof type guard</span>\n        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected string or number, got &#39;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&#39;.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><span style="color:red;">typeof</span> type guard 有两种形式，<code>typeof v === typename</code> 和 <code>typeof v !== typename</code>，其中 <code>typename</code> 必须为 <code>&#39;number&#39;</code>，<code>&#39;string&#39;</code>，<code>&#39;boolean&#39;</code>，<code>&#39;symbol&#39;</code> 四者之一，若为其它值，TypeScript 则不会将这个表达式视为 type guard。</p><h4 id="instanceof-type-guards" tabindex="-1"><span style="color:red;">instanceof</span> type guards <a class="header-anchor" href="#instanceof-type-guards" aria-hidden="true">#</a></h4><p>对于非原始类型，即类的实例，使用 <code>instanceof</code> 进行 type guard，<code>instanceof</code> 左边是实例对象，右边是类的构造函数：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>\n  <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">SpaceRepeatingPadder</span> <span class="token keyword">implements</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> numSpaces<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n  <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>numSpaces <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">getNumberOfSpace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numSpaces\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">StringPadder</span> <span class="token keyword">implements</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n  <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">getRandomPadder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.5</span> <span class="token operator">?</span>\n      <span class="token keyword">new</span> <span class="token class-name">SpaceRepeatingPadder</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">:</span>\n      <span class="token keyword">new</span> <span class="token class-name">StringPadder</span><span class="token punctuation">(</span><span class="token string">&quot;  &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> padder <span class="token operator">=</span> <span class="token function">getRandomPadder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>padder <span class="token keyword">instanceof</span> <span class="token class-name">StringPadder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// padder 缩窄为 StringPadder 类型</span>\n  padder<span class="token punctuation">.</span><span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// padder 缩窄为 SpaceRepeatingPadder 类型</span>\n  padder<span class="token punctuation">.</span><span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n  padder<span class="token punctuation">.</span><span class="token function">getNumberOfSpace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="nullable-types" tabindex="-1">Nullable Types <a class="header-anchor" href="#nullable-types" aria-hidden="true">#</a></h3><p>TypeScript 有两个特殊类型：<code>null</code> 和 <code>undefined</code>，默认情况下，<code>null</code> 和 <code>undefined</code> 可以赋值给任何类型的变量。也就是说在默认情况下，当你声明某个类型的变量时，实际上变量的类型是当前声明类型与 <code>null</code> 和 <code>undefined</code> 的联合类型。这可能不是我们想要的效果，要解决这个问题，可以在配置文件 <code>tsconfig.json</code> 中将 <code>compilerOptions.strictNullChecks</code> 选项设置为 <code>true</code>：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n    <span class="token property">&quot;strictNullChecks&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这样设置之后，声明变量时就不会自动包含 <code>null</code> 和 <code>undefined</code> 类型，除非你显式的声明为联合类型。</p><p>当开启了严格空检查之后，可选参数/属性(optional parameters / properties)的类型会自动加上 <code>| undefined</code>：</p><div class="language-ts"><pre><code><span class="token comment">// optional parameters</span>\n<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">?</span><span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// y 的类型为 number | undefined</span>\n  <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// error, null 类型不能赋值给 number | undefined 类型</span>\n\n<span class="token comment">// optional properties</span>\n<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">I</span></span> <span class="token punctuation">{</span>\n  a<span class="token operator">:</span> <span class="token builtin">number</span>\n  b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token comment">// b 的实际类型为： number | undefined</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">I</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\ni<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// ok</span>\ni<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">undefined</span> <span class="token comment">// error, undefined 不能赋值给 number</span>\ni<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment">// ok</span>\ni<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">undefined</span> <span class="token comment">// ok</span>\ni<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// error， null 不能赋值给 number | undefined</span>\n</code></pre></div><h4 id="type-guards-and-type-assertions" tabindex="-1">Type guards and type assertions <a class="header-anchor" href="#type-guards-and-type-assertions" aria-hidden="true">#</a></h4><p>由于 nullable 类型是通过 union 实现的，因此在使用 nullable 类型时需要先消除空类型：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">broken</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> name<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// error, name is possibly undefined</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 在 JavaScript 中常用如下方法消除空值</span>\n<span class="token keyword">function</span> <span class="token function">fixed</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&#39;default&#39;</span>\n  <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> name<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>但是当遇到如下这种情况时，上面消除空类型的方法又不可行：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">broken</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">greeting</span><span class="token punctuation">(</span>greet<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> name<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;, &#39;</span> <span class="token operator">+</span> greet  <span class="token comment">// error, name is possibly undefined</span>\n  <span class="token punctuation">}</span>\n  name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&#39;default&#39;</span>\n  <span class="token keyword">return</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>上面编译器无法消除空类型的原因是，函数内部的嵌套函数的执行上下文是不确定的，编译器无法跟踪嵌套函数所有的调用，尤其是如果嵌套函数被 return 到函数外部，当这个函数被执行时，它内部变量例如 <code>name</code> 的类型是不明确的。</p><p>在这种情况下需要使用类型断言操作符(type assertion operator) <code>!</code> 来手动的消除空值，语法为：<code>identifier!</code>，这将移除变量 <code>identifier</code> 的类型中的 <code>undefined</code> 和 <code>null</code>：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">fixed</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">greeting</span><span class="token punctuation">(</span>greet<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> name<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> name<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;, &#39;</span> <span class="token operator">+</span> greet  <span class="token comment">// ok</span>\n  name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&#39;default&#39;</span>\n  <span class="token keyword">return</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="type-aliases-类型别名" tabindex="-1">Type Aliases (类型别名) <a class="header-anchor" href="#type-aliases-类型别名" aria-hidden="true">#</a></h3><p>类型别名，顾名思义，就是为某个类型创建一个新的名字，并没用创建一个新的类型。类型别名与接口的概念有点类似，但是可以为包括原始类型，联合类型等任何其它类型创建别名：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Name</span> <span class="token operator">=</span> <span class="token builtin">string</span>\n<span class="token keyword">type</span> <span class="token class-name">NameResolver</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span>\n<span class="token keyword">type</span> <span class="token class-name">NameOrResolver</span> <span class="token operator">=</span> Name <span class="token operator">|</span> NameResolver\n\n<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span>p<span class="token operator">:</span> NameOrResolver<span class="token punctuation">)</span><span class="token operator">:</span> Name <span class="token punctuation">{</span>\n  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> p <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> p\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><blockquote><p>注意：为原始类型创建别名不是常见的用法，尽管它可以作为编写文档的一种形式。</p></blockquote><p>类似接口，类型别名也可以是泛型的：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Container<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span>\n</code></pre></div><p>也可以像下面这样在属性中嵌套的引用类型别名本身：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  value<span class="token operator">:</span> <span class="token constant">T</span>\n  left<span class="token operator">:</span> Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>\n  right<span class="token operator">:</span> Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>除此之外，类型别名不能出现在声明语句右边的任何位置，下面这样是错误的：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">myAlias</span> <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>myAlias<span class="token operator">&gt;</span> <span class="token comment">// error</span>\n</code></pre></div><h4 id="interfaces-vs-type-aliases" tabindex="-1">Interfaces vs. Type Aliases <a class="header-anchor" href="#interfaces-vs-type-aliases" aria-hidden="true">#</a></h4><p>如前面所说的，类型别名可以跟接口非常相似，但是它们之间还是有一些微妙的差别。其中一个重要的差别是，type aliases 不能被扩展(extended)和实现(implemented)，也不能去扩展和实现其它类型，当需要完成这样的任务时，请使用接口。</p><h3 id="string-literal-types" tabindex="-1">String Literal Types <a class="header-anchor" href="#string-literal-types" aria-hidden="true">#</a></h3><p>字符串字面量类型允许你为一个字符串变量指定一个确定的值。字符串字面量类型通常与联合类型，类型守卫以及类型别名一起使用，你可以使用这些特性去模拟字符串枚举的行为：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Easing</span> <span class="token operator">=</span> <span class="token string">&#39;ease-in&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;ease-out&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;ease-in-out&#39;</span>\n\n<span class="token keyword">class</span> <span class="token class-name">UIElement</span> <span class="token punctuation">{</span>\n  <span class="token function">animate</span><span class="token punctuation">(</span>dx<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> dy<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> easing<span class="token operator">:</span> Easing<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&#39;ease-in&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&#39;ease-out&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&#39;ease-in-out&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// error</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> button <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UIElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nbutton<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&#39;ease-in&#39;</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\nbutton<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&#39;uneasy&#39;</span><span class="token punctuation">)</span> <span class="token comment">// error，&#39;uneasy&#39; 类型不能赋值给 &#39;ease-in&#39; | &#39;ease-out&#39; | &#39;ease-in-out&#39; 类型</span>\n</code></pre></div><p>如上面看到的，你只能传递三个允许的字符，其它任何值都会造成错误。</p><h3 id="numeric-literal-types" tabindex="-1">Numeric Literal Types <a class="header-anchor" href="#numeric-literal-types" aria-hidden="true">#</a></h3><p>与字符串字面量类型类似，也有数值字面量类型：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">rollDice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">|</span> <span class="token number">6</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 只能返回 1，2，3，4，5，6，这六个数字之一，返回任何其它值都是错误</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="enum-member-types" tabindex="-1">Enum Member Types <a class="header-anchor" href="#enum-member-types" aria-hidden="true">#</a></h3><p>前面讲<a href="#des">枚举</a>的时候有说过，枚举成员也可以当作类型来使用，整个枚举可以看作是枚举成员类型的一个联合(union)。</p><h3 id="discriminated-unions" tabindex="-1">Discriminated Unions <a class="header-anchor" href="#discriminated-unions" aria-hidden="true">#</a></h3><p>你可以结合使用单例类型(singleton types)，联合类型(union types)，类型守卫(type guards)以及类型别名(type aliases)来创建更高级的模式，即 discriminated unions。</p><blockquote><p>通常我们说的单例类型(singleton types)，指的就是枚举成员类型以及数值/字符串字面量类型。</p></blockquote><p>要实现 discriminated unions，需要实现下面三点：</p><ol><li>被联合的所有类型都有一个相同的的单例类型属性 -- the discriminant</li></ol><div class="language-ts"><pre><code><span class="token comment">// 每个类型都有属性 kind，且为单例类型</span>\n<span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>\n  kind<span class="token operator">:</span> <span class="token string">&quot;square&quot;</span><span class="token punctuation">;</span>\n  size<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">interface</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>\n  kind<span class="token operator">:</span> <span class="token string">&quot;rectangle&quot;</span><span class="token punctuation">;</span>\n  width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>\n  height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>\n  kind<span class="token operator">:</span> <span class="token string">&quot;circle&quot;</span><span class="token punctuation">;</span>\n  radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><ol start="2"><li>创建一个联合类型</li></ol><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Shape</span> <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle <span class="token operator">|</span> Circle\n</code></pre></div><ol start="3"><li>使用 discriminated union：</li></ol><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 这里会有一个隐式的 type guard 的效果</span>\n    <span class="token comment">// 编译器能够通过 s.kind 属性的 singleton type 来缩窄 s 的类型</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment">// s 的类型被缩窄为 Square</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span> <span class="token comment">// s 的类型被缩窄为 Rectangle</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// s 的类型被缩窄为 Circle</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>继续看下面的情况，还是上面的 <code>area</code> 函数，如果将 <code>switch</code> 的分支减少一个：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">{</span> kind<span class="token operator">:</span> <span class="token string">&#39;circle&#39;</span><span class="token punctuation">,</span> radius<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// ok，undefined</span>\n</code></pre></div><p>可以看到，即使 <code>switch</code> 的分支没有覆盖 <code>s</code> 的 discriminated union 的所有情况，编译器也不会提示错误。在这种情况下如果我们希望在编译阶段就发现问题，可以打开严格空检查设置 <code>--strictNullChecks</code>，并为函数显式指定返回类型，比如为 <code>area</code> 函数显式的指定返回类型为 number，下面的代码就不能通过编译检查：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span> <span class="token comment">// error, Function lacks ending return statement and return type does not include &#39;undefined&#39;</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>更多用法请看官方文档。</p><h3 id="polymorphic-this-types-多态的-this-类型" tabindex="-1">Polymorphic <span style="color:red;">this</span> types (多态的 this 类型) <a class="header-anchor" href="#polymorphic-this-types-多态的-this-类型" aria-hidden="true">#</a></h3><p>多态的 this 类型，顾名思义 this 代表的类型是多态的，不是固定的，请看下面的例子：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">BasicCalculator</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">protected</span> value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n  <span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value\n  <span class="token punctuation">}</span>\n  <span class="token function">add</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span> <span class="token comment">// 返回 polymorphic this 类型</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> operand\n    <span class="token keyword">return</span> <span class="token keyword">this</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">multiply</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span> <span class="token comment">// 返回 polymorphic this 类型</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">*=</span> operand\n    <span class="token keyword">return</span> <span class="token keyword">this</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicCalculator</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>因为 <code>add</code>，<code>multiply</code> 方法返回对象本身，因此可以写链式调用方法的语句。现在我们扩展 <code>BasicCalculator</code> 类：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">ScientificCalculator</span> <span class="token keyword">extends</span> <span class="token class-name">BasicCalculator</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span> <span class="token comment">// 返回 polymorphic this 类型</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScientificCalculator</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n</code></pre></div><p>可以看到这里的链式调用语句也能正常工作，这正是因为 <code>BasicCalculator</code> 的 <code>add</code> 和 <code>multiply</code> 方法返回的是 polymorphic this 类型，它能保证 <code>add</code> 和 <code>multiply</code> 在被调用时，将实际返回类型绑定到正确实例类型上。反之，如果 <code>add</code> 和 <code>multiply</code> 不是返回 polymorphic this 类型，而是返回具体的类类型，<code>ScientificCalculator</code> 的实例将无法继续使用链式调用，因为 <code>add</code> 将始终返回 <code>BasicCalculator</code>, 而 <code>BasicCalculator</code> 没有 <code>sin</code> 方法：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">BasicCalculator</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">protected</span> value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n  <span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value\n  <span class="token punctuation">}</span>\n  <span class="token function">add</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> BasicCalculator <span class="token punctuation">{</span> <span class="token comment">// 返回 BasicCalculator</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> operand\n    <span class="token keyword">return</span> <span class="token keyword">this</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">multiply</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> BasicCalculator <span class="token punctuation">{</span> <span class="token comment">// 返回 BasicCalculator</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">*=</span> operand\n    <span class="token keyword">return</span> <span class="token keyword">this</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">ScientificCalculator</span> <span class="token keyword">extends</span> <span class="token class-name">BasicCalculator</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span> <span class="token comment">// 返回 polymorphic this 类型</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">new</span> <span class="token class-name">ScientificCalculator</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error, Property &#39;sin&#39; dose not exist on type &#39;BasicCalculator&#39;</span>\n</code></pre></div><h3 id="index-types" tabindex="-1">Index types <a class="header-anchor" href="#index-types" aria-hidden="true">#</a></h3><p>利用索引类型，编译器可以检查使用动态属性名的代码，例如 JavaScript 中很常见的代码：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">pluck</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> names<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> names<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>在 TypeScript 中利用索引类型查询(index type query)和索引访问操作符(indexed access operator)，可以这样写这个函数：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">pluck</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> names<span class="token operator">:</span> k<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> names<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;Nicholas&#39;</span><span class="token punctuation">,</span>\n  age<span class="token operator">:</span> <span class="token number">34</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> subset1 <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token keyword">let</span> subset2 <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;age&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>\n<span class="token keyword">let</span> subset3 <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&#39;gender&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// error</span>\n</code></pre></div><p>这样 TypeScript 就可以加入类型检查，例如上面 <code>names</code> 的元素必须是 <code>person</code> 的属性，否则不能通过编译。</p><p>上面使用的到的操作符 <code>keyof</code> 称作索引类型查询操作符(index type query operator)，对于任意类型 <code>T</code>，<code>keyof T</code> 代表的是 <code>T</code> 的所有公有属性名的联合类型：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span>\n  age<span class="token operator">:</span> <span class="token builtin">number</span>\n  gender<span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>\n    <span class="token keyword">public</span> author<span class="token operator">:</span> Person<span class="token punctuation">,</span>\n    <span class="token keyword">public</span> title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>\n    <span class="token keyword">public</span> price<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>\n    <span class="token keyword">private</span> publisher<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">type</span> <span class="token class-name">personProps</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Person <span class="token comment">// &quot;name&quot; | &quot;age&quot; | &quot;gender&quot;</span>\n<span class="token keyword">type</span> <span class="token class-name">bookProps</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Book <span class="token comment">// &quot;author&quot; | &quot;title&quot; | &quot;price&quot;，不包含 &quot;publisher&quot;</span>\n</code></pre></div><p>第二个用到的操作符是 <code>T[K]</code>，即索引访问操作符(indexed access operator)，这里类型语法也反映了表达式语法，即 <code>person[&quot;name&quot;]</code> 具有 <code>Person[&quot;name&quot;]</code> 类型，在上面的例子中就是 <code>string</code> 类型，然而在泛型上下文里，<code>T[K]</code> 的类型是根据 <code>T</code> 和 <code>K</code> 的类型动态确定的，这正是它的强大之处：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getProperty</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> o<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token comment">// o[name] 的类型为 T[K]</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// string</span>\n<span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&#39;age&#39;</span><span class="token punctuation">)</span> <span class="token comment">// number</span>\n</code></pre></div><h3 id="mapped-types" tabindex="-1">Mapped types <a class="header-anchor" href="#mapped-types" aria-hidden="true">#</a></h3><p>这个类型太高级，详情请看<a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="noopener noreferrer">官方文档</a>。</p><h3 id="conditional-types" tabindex="-1">Conditional Types <a class="header-anchor" href="#conditional-types" aria-hidden="true">#</a></h3><p>TypeScript 2.8 版本引入了条件类型，形式如下：</p><div class="language-ts"><pre><code><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">X</span> <span class="token operator">:</span> <span class="token constant">Y</span>\n</code></pre></div><p>意思是，如果 <code>T</code> 可赋给 <code>U</code>，结果类型为 <code>X</code>，否者为 <code>Y</code>。</p><p>一个条件类型 <code>T extends U ? X : Y</code> 要么被解析为 <code>X</code> 或 <code>Y</code>，要么被延迟解析，当条件判断依赖于一个或多个类型参数时就会出现延迟解析。是否解析为 <code>X</code> 或 <code>Y</code>, 或推迟解析，取决于类型系统是否有足够的信息去推断出 <code>T</code> 是否总是可以赋给 <code>U</code>.</p><p>详情请看<a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="noopener noreferrer">官方文档</a></p><p>2.8 版本预定义了几个条件类型：</p><ul><li><code>Exclude&lt;T, U&gt;</code>：Exclude from <code>T</code> those types that are assignable to <code>U</code></li><li><code>Extract&lt;T, U&gt;</code>：Extract from <code>T</code> those types that are assignable to <code>U</code></li><li><code>NonNullable&lt;T&gt;</code>：Exclude <code>null</code> and <code>undefined</code> from <code>T</code></li><li><code>ReturnType&lt;T&gt;</code>：Obtain the return type of a function type</li><li><code>InstanceType&lt;T&gt;</code>：Obtain the instance type of a constructor function type</li></ul><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T00</span></span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;b&quot; | &quot;d&quot;</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T01</span></span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;a&quot; | &quot;c&quot;</span>\n\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T02</span></span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T03</span></span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// () =&gt; void</span>\n\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T04</span></span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T05</span></span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// (() =&gt; string) | string[]</span>\n\n<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> s <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>\n    x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T10</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T11</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// void</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T12</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// {}</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T13</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span><span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// number[]</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T14</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> f1<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// { a: number, b: string }</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T15</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// any</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T16</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// never</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T17</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T18</span></span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>\n\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T20</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> <span class="token constant">C</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// C</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T21</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// any</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T22</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// never</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T23</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>\n<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T24</span></span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>\n</code></pre></div><h2 id="modules" tabindex="-1">Modules <a class="header-anchor" href="#modules" aria-hidden="true">#</a></h2><p>TypeScript 继承了 ES6 中 modules 的概念，modules 在它自己的作用域内被执行，而不是在全局作用域。 在一个 module 中声明的变量、函数、类等等在其它 modules 中是不可见的，除非显式的将这些变量导出。而要在一个module 中使用其它 modules 导出的变量，必须先将这些变量导入。</p><p>任何包含 top-level <code>import</code> 或 <code>export</code> 的文件都被视为 module，而不包含 top-level <code>import</code> 或 <code>export</code> 的文件被视为普通脚本，它里面的内容暴露在全局作用域内。</p><h3 id="export" tabindex="-1">Export <a class="header-anchor" href="#export" aria-hidden="true">#</a></h3><h4 id="exporting-a-declaration" tabindex="-1">Exporting a declaration <a class="header-anchor" href="#exporting-a-declaration" aria-hidden="true">#</a></h4><p>使用关键字 <code>export</code> 可以导出任何声明，例如 variable, function, class, interface, type alias, enum 等等：</p><p><em>module.ts</em></p><div class="language-ts"><pre><code><span class="token comment">// 导出 interface</span>\n<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">StringValidator</span> <span class="token punctuation">{</span>\n  <span class="token function">isAcceptable</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 导出 variable</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> numberRegexp <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[0-9]+$</span><span class="token regex-delimiter">/</span></span>\n<span class="token comment">// 导出 class</span>\n<span class="token class-name"><span class="token keyword">export</span></span> <span class="token keyword">class</span> <span class="token class-name">ZipCodeValidator</span> <span class="token keyword">implements</span> <span class="token class-name">StringValidator</span> <span class="token punctuation">{</span>\n  <span class="token function">isAcceptable</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> s<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> numberRegexp<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><em>module.ts</em> 也可以改写为：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">StringValidator</span> <span class="token punctuation">{</span>\n  <span class="token function">isAcceptable</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> numberRegexp <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[0-9]+$</span><span class="token regex-delimiter">/</span></span>\n\n<span class="token keyword">class</span> <span class="token class-name">ZipCodeValidator</span> <span class="token keyword">implements</span> <span class="token class-name">StringValidator</span> <span class="token punctuation">{</span>\n  <span class="token function">isAcceptable</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> s<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> numberRegexp<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 按原名导出</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> StringValidator<span class="token punctuation">,</span> numberRegexp <span class="token punctuation">}</span>\n<span class="token comment">// 按别名 validatorAlias 导出</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> ZipCodeValidator <span class="token keyword">as</span> validatorAlias <span class="token punctuation">}</span>\n</code></pre></div><h4 id="re-exports" tabindex="-1">Re-exports <a class="header-anchor" href="#re-exports" aria-hidden="true">#</a></h4><p>如果一个模块要扩展另一个模块，并暴露它的一部分功能，可以使用 re-export 语法：</p><p><em>extended-module.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ParseIntBasedZipCodeValidator</span> <span class="token punctuation">{</span>\n  <span class="token function">isAcceptable</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> s<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> s\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 以别名的方式重新导出 ZipCodeValidator</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> ZipCodeValidator <span class="token keyword">as</span> RegExpBasedZipCodeValidator <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./module&#39;</span>\n<span class="token comment">// re-export 整个 module</span>\n<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">&#39;./module&#39;</span>\n</code></pre></div><p>re-export 不会将 original module 导入到当前 module 的作用域，也不会引入一个本地变量。</p><h3 id="import" tabindex="-1">Import <a class="header-anchor" href="#import" aria-hidden="true">#</a></h3><p><em>another-module.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> StringValidator<span class="token punctuation">,</span> numberRegexp<span class="token punctuation">,</span> ZipCodeValidator <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./module&#39;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> myValidator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipCodeValidator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>导入变量时也可以重命名：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ZipCodeValidator <span class="token keyword">as</span> ZipCodeAlias <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./module&#39;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> myValidator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipCodeAlias</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>将整个 module 作为一个变量导入：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Validator <span class="token keyword">from</span> <span class="token string">&#39;./module&#39;</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> myValidator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Validator</span><span class="token punctuation">.</span><span class="token function">ZipCodeValidator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">class</span> <span class="token class-name">NewValidator</span> <span class="token keyword">implements</span> <span class="token class-name">Validator</span><span class="token punctuation">.</span>StringValidator <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="default-exports" tabindex="-1">Default exports <a class="header-anchor" href="#default-exports" aria-hidden="true">#</a></h3><p>每个 module 可以有一个 <code>default</code> 导出，而且只能有一个</p><p><em>default-export-module.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">ParseIntBasedZipCodeValidator</span> <span class="token punctuation">{</span>\n  <span class="token function">isAcceptable</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> s<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> s\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>使用 <code>export default</code> 导出的模块，导入的方式也有所不同： <em>import-default-module.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">import</span> Validator <span class="token keyword">from</span> <span class="token string">&#39;./default-export-module&#39;</span>\n\n<span class="token keyword">let</span> myValidator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Validator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p><code>default</code> 导出可以导出 anonymous function： <em>anonymous.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>length <span class="token punctuation">}</span>\n</code></pre></div><p><em>test.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">import</span> myFunc <span class="token keyword">from</span> <span class="token string">&#39;./anonymous&#39;</span>\n\n<span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// 5</span>\n</code></pre></div><p>甚至可以导出字面常量： <em>OneTwoThree.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">&#39;123&#39;</span>\n</code></pre></div><p><em>log.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">import</span> num <span class="token keyword">from</span> <span class="token string">&#39;./OneTwoThree&#39;</span>\n\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">// &#39;123&#39;</span>\n</code></pre></div><h3 id="export-and-import-require" tabindex="-1"><code>export =</code> and <code>import = require()</code> <a class="header-anchor" href="#export-and-import-require" aria-hidden="true">#</a></h3><p>TypeScript 支持模拟传统 CommonJS 和 AMD 的工作流。</p><p><code>export =</code> 语法用于导出单个对象，可以是一个 class、interface、namespace、function、enum：</p><p><em>ZipCodeValidator.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">let</span> numberRegexp <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[0-9]+$</span><span class="token regex-delimiter">/</span></span>\n<span class="token keyword">class</span> <span class="token class-name">ZipCodeValidator</span> <span class="token punctuation">{</span>\n  <span class="token function">isAcceptable</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> s<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> numberRegexp<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">export</span> <span class="token operator">=</span> ZipCodeValidator\n</code></pre></div><p>对于使用 <code>export =</code> 导出的模块，必须使用 <code>import module = require(&#39;module&#39;)</code> 语法导入：</p><p><em>Test.ts</em></p><div class="language-ts"><pre><code><span class="token keyword">import</span> zip <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span>&#39;<span class="token punctuation">.</span><span class="token operator">/</span>ZipCodeValidator<span class="token punctuation">)</span>\n\n<span class="token comment">// Some samples to try</span>\n<span class="token keyword">let</span> strings <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;98052&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;101&quot;</span><span class="token punctuation">]</span>\n\n<span class="token comment">// Validators to use</span>\n<span class="token keyword">let</span> validator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">zip</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// Show whether each string passed each validator</span>\nstrings<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> s <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; - </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> validator<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot;matches&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;does not match&quot;</span> <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>关于 Module 的更多内容可以参考<a href="https://basarat.gitbooks.io/typescript/content/docs/project/modules.html" target="_blank" rel="noopener noreferrer">这里</a></p>',385)];var c=n(o,[["render",function(n,p,t,o,c,l){return a(),s("div",null,e)}]]);export{t as __pageData,c as default};
