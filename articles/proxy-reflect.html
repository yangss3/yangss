<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Proxy 和 Reflect | YangSS</title>
    <meta name="description" content="Nicholas Yang's personal blog.">
    <link rel="stylesheet" href="/yangss/assets/style.e829c237.css">
    <link rel="modulepreload" href="/yangss/assets/Home.220af317.js">
    <link rel="modulepreload" href="/yangss/assets/app.b2baf6b4.js">
    <link rel="modulepreload" href="/yangss/assets/articles_proxy-reflect.md.02419337.lean.js">
    <link rel="modulepreload" href="/yangss/assets/app.b2baf6b4.js">
    <meta name="twitter:title" content="Proxy 和 Reflect | YangSS">
    <meta property="og:title" content="Proxy 和 Reflect | YangSS">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/yangss/" aria-label="YangSS, back to home" data-v-40587210 data-v-7ac13a1e><!----> YangSS</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item active" href="/yangss/articles/" data-v-49fe041d>Articles <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/notes/" data-v-49fe041d>Notes <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/projects" data-v-49fe041d>Projects <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--[--><div class="flex space-x-5 ml-5"><button class="icon-button" title="Bookmarks" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24"><path d="M17 18l-5-2.18L7 18V5h10m0-2H7a2 2 0 0 0-2 2v16l7-3l7 3V5a2 2 0 0 0-2-2z" fill="currentColor"></path></svg><!--]--></button><button class="icon-button" title="GitHub" data-v-5dee39e6><a href="https://github.com/yangss3" target="_blank" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24"><path fill="currentColor" d="M16.24 22a1 1 0 0 1-1-1v-2.6a2.15 2.15 0 0 0-.54-1.66a1 1 0 0 1 .61-1.67C17.75 14.78 20 14 20 9.77a4 4 0 0 0-.67-2.22a2.75 2.75 0 0 1-.41-2.06a3.71 3.71 0 0 0 0-1.41a7.65 7.65 0 0 0-2.09 1.09a1 1 0 0 1-.84.15a10.15 10.15 0 0 0-5.52 0a1 1 0 0 1-.84-.15a7.4 7.4 0 0 0-2.11-1.09a3.52 3.52 0 0 0 0 1.41a2.84 2.84 0 0 1-.43 2.08a4.07 4.07 0 0 0-.67 2.23c0 3.89 1.88 4.93 4.7 5.29a1 1 0 0 1 .82.66a1 1 0 0 1-.21 1a2.06 2.06 0 0 0-.55 1.56V21a1 1 0 0 1-2 0v-.57a6 6 0 0 1-5.27-2.09a3.9 3.9 0 0 0-1.16-.88a1 1 0 1 1 .5-1.94a4.93 4.93 0 0 1 2 1.36c1 1 2 1.88 3.9 1.52a3.89 3.89 0 0 1 .23-1.58c-2.06-.52-5-2-5-7a6 6 0 0 1 1-3.33a.85.85 0 0 0 .13-.62a5.69 5.69 0 0 1 .33-3.21a1 1 0 0 1 .63-.57c.34-.1 1.56-.3 3.87 1.2a12.16 12.16 0 0 1 5.69 0c2.31-1.5 3.53-1.31 3.86-1.2a1 1 0 0 1 .63.57a5.71 5.71 0 0 1 .33 3.22a.75.75 0 0 0 .11.57a6 6 0 0 1 1 3.34c0 5.07-2.92 6.54-5 7a4.28 4.28 0 0 1 .22 1.67V21a1 1 0 0 1-.94 1z"></path></svg><!--]--></a></button><button class="icon-button" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24" style="display:none;"><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938A7.999 7.999 0 0 0 4 12z" fill="currentColor"></path></svg><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24" style=""><path d="M12 18a6 6 0 1 1 0-12a6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636L5.636 7.05L3.515 4.93zM16.95 18.364l1.414-1.414l2.121 2.121l-1.414 1.414l-2.121-2.121zm2.121-14.85l1.414 1.415l-2.121 2.121l-1.414-1.414l2.121-2.121zM5.636 16.95l1.414 1.414l-2.121 2.121l-1.414-1.414l2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z" fill="currentColor"></path></svg><!--]--></button></div><!--]--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item active" href="/yangss/articles/" data-v-49fe041d>Articles <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/notes/" data-v-49fe041d>Notes <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/projects" data-v-49fe041d>Projects <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-17c48e2f><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/async-setup">异步 setup</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/currying">柯里化（Currying）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/decorator">装饰者（Decorator）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/effective-ts">Effective TypeScript</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/yangss/articles/proxy-reflect">Proxy 和 Reflect</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#proxy">Proxy</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#使用-get-钩子设置默认值">使用 get 钩子设置默认值</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#使用-set-钩子进行验证">使用 set 钩子进行验证</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#使用-ownkeys-和-getownpropertydescriptor-进行迭代">使用 ownKeys 和 getOwnPropertyDescriptor 进行迭代</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#使用-deleteproperty-拦截属性删除">使用 deleteProperty 拦截属性删除</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#使用-has-钩子拦截属性检查">使用 has 钩子拦截属性检查</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#使用-apply-钩子代理函数调用">使用 apply 钩子代理函数调用</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect">Reflect</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#代理一个-getter">代理一个 getter</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#proxy-的局限">Proxy 的局限</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#内部插槽（internal-slots）">内部插槽（Internal slots）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#私有字段">私有字段</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#可取消的-proxy">可取消的 Proxy</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#几个用例">几个用例</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#数组负索引">数组负索引</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#observable">Observable</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/settimeout-setinterval">setTimeout 和 setInterval</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/switch-true-pattern">使用 switch(ture) 模式</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/weakmap-weakset">深入理解 WeakMap 和 WeakSet</a><!----></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="proxy-和-reflect" tabindex="-1">Proxy 和 Reflect <a class="header-anchor" href="#proxy-和-reflect" aria-hidden="true">#</a></h1><p class="text-gray-300 dark:text-gray-600 flex items-center space-x-2 mb-24px"><svg class="relative top-2px !top-1px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 48 48"><g fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"><path d="M5 19h38v21a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V19z"></path><path d="M5 9a2 2 0 0 1 2-2h34a2 2 0 0 1 2 2v10H5V9z"></path><path d="M16 4v8" stroke-linecap="round"></path><path d="M32 4v8" stroke-linecap="round"></path><path d="M28 34h6" stroke-linecap="round"></path><path d="M14 34h6" stroke-linecap="round"></path><path d="M28 26h6" stroke-linecap="round"></path><path d="M14 26h6" stroke-linecap="round"></path></g></svg><span>2020/10/18</span></p><h2 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-hidden="true">#</a></h2><p>一个 <code>Proxy</code> 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地将操作转发给原对象。</p><p>语法：</p><div class="language-js"><pre><code><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
</code></pre></div><p>其中：</p><ul><li><code>target</code> —— 是要包装的对象，可以是任何东西，包括函数</li><li><code>handler</code> —— 代理配置：带有“钩子”的对象。比如 <code>get</code> 钩子用于读取 <code>target</code> 属性，<code>set</code> 钩子写入 <code>target</code> 属性等等</li></ul><p>对 <code>proxy</code> 进行操作时，如果在 <code>handler</code> 中存在相应的钩子，则该钩子会被调用，并且 Proxy 有机会对该操作进行代理，否则将直接对 <code>target</code> 进行操作。</p><p>首先，让我们创建一个没有任何钩子的代理：</p><div class="language-js"><pre><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 空的handler对象</span>

proxy<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">5</span> <span class="token comment">// 写入 Proxy 对象 (1)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>test<span class="token punctuation">)</span> <span class="token comment">// 返回 5，test属性出现在了 target 上！</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>test<span class="token punctuation">)</span> <span class="token comment">// 还是 5，我们也可以从 proxy 对象读取它 (2)</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> proxy<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// 返回 test，迭代也正常工作！ (3)</span>
</code></pre></div><p>由于没有钩子，所有对 <code>proxy</code> 的操作都直接转发给 <code>target</code>：</p><ol><li>写入操作 <code>proxy.test=</code> 会将值写入 <code>target</code></li><li>读取操作 <code>proxy.test</code> 会从 <code>target</code> 返回对应的值</li><li>迭代 <code>proxy</code> 会从 <code>target</code> 返回对应的值</li></ol><p>我们可以看到，如果没有任何钩子，<code>proxy</code> 是一个 <code>target</code> 的透明包装。</p><p><code>Proxy</code> 是一种特殊的对象。它没有自己的属性，如果 <code>handler</code> 为空，则透明地将操作转发给 <code>target</code></p><p>要激活更多功能，我们需要添加钩子来拦截操作，那我们可以用它们拦截什么？</p><p>对于对象的大多数操作，JavaScript 规范中都有一个所谓的“内部方法”，它描述了最底层的工作方式。 例如 <code>[[Get]]</code>，用于读取属性的内部方法， <code>[[Set]]</code>，用于写入属性的内部方法，等等。这些方法仅在规范中使用，我们不能直接通过方法名调用它们。Proxy 钩子会拦截这些方法的调用，对于每个内部方法，下表中都有一个钩子，用于拦截对应的操作：</p><table><thead><tr><th style="text-align:center;">内部方法</th><th style="text-align:center;">Handler 方法</th><th style="text-align:center;">何时触发</th></tr></thead><tbody><tr><td style="text-align:center;">[[Get]]</td><td style="text-align:center;">get</td><td style="text-align:center;">读取属性</td></tr><tr><td style="text-align:center;">[[Set]]</td><td style="text-align:center;">set</td><td style="text-align:center;">写入属性</td></tr><tr><td style="text-align:center;">[[HasProperty]]</td><td style="text-align:center;">has</td><td style="text-align:center;">in 运算符</td></tr><tr><td style="text-align:center;">[[Delete]]</td><td style="text-align:center;">deleteProperty</td><td style="text-align:center;">delete 操作</td></tr><tr><td style="text-align:center;">[[Call]]</td><td style="text-align:center;">apply</td><td style="text-align:center;">proxy 对象作为函数被调用</td></tr><tr><td style="text-align:center;">[[Construct]]</td><td style="text-align:center;">construct</td><td style="text-align:center;">new 操作</td></tr><tr><td style="text-align:center;">[[GetPrototypeOf]]</td><td style="text-align:center;">getPrototypeOf</td><td style="text-align:center;">Object.getPrototypeOf</td></tr><tr><td style="text-align:center;">[[SetPrototypeOf]]</td><td style="text-align:center;">setPrototypeOf</td><td style="text-align:center;">Object.setPrototypeOf</td></tr><tr><td style="text-align:center;">[[IsExtensible]]</td><td style="text-align:center;">isExtensible</td><td style="text-align:center;">Object.isExtensible</td></tr><tr><td style="text-align:center;">[[PreventExtensions]]</td><td style="text-align:center;">preventExtensions</td><td style="text-align:center;">Object.preventExtensions</td></tr><tr><td style="text-align:center;">[[DefineOwnProperty]]</td><td style="text-align:center;">defineProperty</td><td style="text-align:center;">Object.defineProperty, Object.defineProperties</td></tr><tr><td style="text-align:center;">[[GetOwnProperty]]</td><td style="text-align:center;">getOwnPropertyDescriptor</td><td style="text-align:center;">Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries</td></tr><tr><td style="text-align:center;">[[OwnPropertyKeys]]</td><td style="text-align:center;">ownKeys</td><td style="text-align:center;">Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object/keys/values/entries</td></tr></tbody></table><p>当由内部方法和钩子来完成操作时，JavaScript 强制执行某些不变式。其中大多数用于返回值：</p><ul><li><code>[[Set]]</code> 如果值已成功写入，则必须返回 <code>true</code>，否则返回 <code>false</code></li><li><code>[[Delete]]</code> 如果已成功删除该值，则必须返回 <code>true</code>，否则返回 <code>false</code></li><li>……依此类推，我们将在下面的示例中看到更多内容</li></ul><p>还有其他一些不变量，例如：</p><ul><li><code>[[GetPrototypeOf]]</code> 应用于代理对象的，必须返回与 <code>[[GetPrototypeOf]]</code> 应用于被代理对象相同的值。换句话说，读取代理对象的原型必须始终返回被代理对象的原型。</li></ul><p>钩子可以拦截这些操作，但是必须遵循这些规则。不变量确保语言功能的正确和一致的行为。完整的不变量列表请查看<a href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots" target="_blank" rel="noopener noreferrer">规范</a>。如果你不做奇怪的事情，就不会违反它们。</p><p>让我们看看实际示例中的工作原理。</p><h3 id="使用-get-钩子设置默认值" tabindex="-1">使用 <code>get</code> 钩子设置默认值 <a class="header-anchor" href="#使用-get-钩子设置默认值" aria-hidden="true">#</a></h3><p>最常见的钩子是用于读取/写入属性。要拦截读取操作，<code>handler</code> 应该有 <code>get(target, property, receiver)</code> 方法。读取属性时触发该方法，参数如下：</p><ul><li><code>target</code> —— 是目标对象，该对象作为第一个参数传递给 <code>new Proxy</code></li><li><code>property</code> —— 目标属性名</li><li><code>receiver</code> —— 如果目标属性是一个 <code>getter</code> 访问器属性，则 <code>receiver</code> 就是本次读取属性所在的 <code>this</code> 对象。通常，这就是 <code>proxy</code> 对象本身（或者，如果我们从代理继承，则是从该代理继承的对象）。现在我们不需要此参数，稍后将对其进行详细说明。</li></ul><p>让我们用 <code>get</code> 实现对象的默认值。</p><p>通常，当人们尝试获取不存在的数组项时，他们会得到 <code>undefined</code>, 但是我们会将常规数组包装到代理中，以捕获读取操作并在没有此类属性的情况下返回 0：</p><div class="language-js"><pre><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>

numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">0</span> <span class="token comment">// 默认值</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span><span class="token number">123</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 0 (没有这样的元素)</span>
</code></pre></div><p>可以看到，使用 <code>get</code> 钩子非常容易。</p><p>我们可以用 <code>Proxy</code> 来实现任何读取默认值的逻辑，想象一下，我们有一本词典，上面有单词及其翻译：</p><div class="language-js"><pre><code><span class="token keyword">const</span> dictionary <span class="token operator">=</span> <span class="token punctuation">{</span>
  hello<span class="token operator">:</span> <span class="token string">&#39;你好&#39;</span><span class="token punctuation">,</span>
  bye<span class="token operator">:</span> <span class="token string">&#39;再见&#39;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 你好</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">&#39;welcome&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre></div><p>现在，如果访问的单词不存在，从 <code>dictionary</code> 读取将返回 <code>undefined</code>。但实际上，返回一个未翻译单词通常比 <code>undefined</code> 要好。用 <code>Proxy</code> 可以很容易做到这一点：</p><div class="language-js"><pre><code><span class="token keyword">const</span> dictionary <span class="token operator">=</span> <span class="token punctuation">{</span>
  hello<span class="token operator">:</span> <span class="token string">&#39;你好&#39;</span><span class="token punctuation">,</span>
  bye<span class="token operator">:</span> <span class="token string">&#39;再见&#39;</span>
<span class="token punctuation">}</span>

dictionary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> phrase<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截读取属性操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>phrase <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果字典包含该短语</span>
      <span class="token keyword">return</span> target<span class="token punctuation">[</span>phrase<span class="token punctuation">]</span> <span class="token comment">// 返回译文</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 否则返回未翻译的短语</span>
      <span class="token keyword">return</span> phrase
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 你好</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">&#39;welcome&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// welcome 未翻译</span>
</code></pre></div><p>请注意代理如何覆盖变量：</p><div class="language-js"><pre><code>dictionary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
</code></pre></div><p>代理应该在所有地方都完全替代了目标对象。目标对象被代理后，任何人都不应该再引用目标对象。否则很容易搞砸。</p><h3 id="使用-set-钩子进行验证" tabindex="-1">使用 <code>set</code> 钩子进行验证 <a class="header-anchor" href="#使用-set-钩子进行验证" aria-hidden="true">#</a></h3><p>当写入属性时 <code>set</code> 钩子触发， 需要在 <code>handler</code> 中定义 <code>set(target, property, value, receiver)</code> 方法：</p><ul><li><code>target</code> —— 是目标对象，该对象作为第一个参数传递给 <code>new Proxy</code></li><li><code>property</code> —— 目标属性名称</li><li><code>value</code> —— 目标属性要设置的值</li><li><code>receiver</code> —— 与 <code>get</code> 钩子类似，仅与 <code>setter</code> 访问器相关</li></ul><p>假设我们想要一个专门用于存放数字的数组。如果添加了其它类型的值，则应该抛出一个错误：</p><div class="language-js"><pre><code><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">// (*)</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截写入操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">==</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> val
      <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// 不要忘记返回 true</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">// 失败时要返回 false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 添加成功</span>
numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 添加成功</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 2</span>
numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span> <span class="token comment">// TypeError （proxy 的 `set` 操作返回 false）</span>
</code></pre></div><p>注意到 <code>Array</code> 的内建方法依然生效！ 当使用 <code>push</code> 方法添加值时，<code>length</code> 属性会自动增加。我们的代理对象 <code>Proxy</code> 不会破坏任何东西。</p><p>我们不必重写诸如 <code>push</code> 和 <code>unshift</code> 等添加元素的数组方法，因为 <code>Proxy</code> 钩子拦截的是内部方法的调用，而这些添加数组元素的方法在内部都使用 <code>[[Set]]</code> 方法。</p><h3 id="使用-ownkeys-和-getownpropertydescriptor-进行迭代" tabindex="-1">使用 <code>ownKeys</code> 和 <code>getOwnPropertyDescriptor</code> 进行迭代 <a class="header-anchor" href="#使用-ownkeys-和-getownpropertydescriptor-进行迭代" aria-hidden="true">#</a></h3><p><code>Object.keys</code>，<code>for..in</code> 循环和大多数其他遍历对象属性的方法都使用 <code>[[OwnPropertyKeys]]</code> 内部方法（由 <code>ownKeys</code> 钩子拦截) 来获取属性列表。</p><p>这些方法在细节上有所不同：</p><ul><li><code>Object.getOwnPropertyNames(obj)</code> 返回非 <code>Symbol</code> 键</li><li><code>Object.getOwnPropertySymbols(obj)</code> 返回 <code>Symbol</code> 键</li><li><code>Object.keys/values(obj)</code> 返回带有 <code>enumerable</code> 标记的非 <code>Symbol</code> 键值对</li><li><code>for..in</code> 循环遍历所有带有 <code>enumerable</code> 标记的非 <code>Symbol</code> 键，以及原型对象的键</li></ul><p>在下面的示例中，我们使用 <code>ownKeys</code> 钩子拦截 <code>for..in</code> 对 <code>user</code> 的遍历，还使用 <code>Object.keys</code> 和 <code>Object.values</code> 来跳过以下划线 <code>_</code> 开头的属性：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  _password<span class="token operator">:</span> <span class="token string">&#39;******&#39;</span>
<span class="token punctuation">}</span>

user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">startWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// &quot;ownKeys&quot; 过滤掉le _password</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// name，age</span>

<span class="token comment">// 对这些方法同样有效：</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// name, age</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// John, 30</span>
</code></pre></div><p>如果让 <code>ownKeys</code> 钩子返回目标对象不存在的键呢？</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// nothing</span>
</code></pre></div><p>什么都没有，这是为什么呢？</p><p>原因很简单，<code>Object.keys</code> 仅返回带有 <code>enumerable</code> 标记的属性。为了检查它，该方法会对每个属性调用 <code>[[GetOwnProperty]]</code> 来获得属性描述符。在这里，由于目标对象没有这个属性，其描述符为空，没有 <code>enumerable</code> 标记，因此它将略过该属性。</p><p>所以要想让 <code>Object.keys</code> 返回目标对象不存在的属性，我们还需要拦截 <code>[[GetOwnProperty]]</code> 内部方法（使用 <code>getOwnPropertyDescriptor</code>），对于不存在的属性，让它返回描述符 <code>enumerable: true</code>：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</code></pre></div><p>是不是很有趣？</p><h3 id="使用-deleteproperty-拦截属性删除" tabindex="-1">使用 <code>deleteProperty</code> 拦截属性删除 <a class="header-anchor" href="#使用-deleteproperty-拦截属性删除" aria-hidden="true">#</a></h3><p>有一个普遍的约定，即下划线 <code>_</code> 前缀的属性和方法是内部的，不应从对象外部访问它们。</p><p>从技术上讲，这是可能的，我们需要这些钩子进行代理：</p><ul><li><code>get</code> —— 读取此类属性时抛出错误</li><li><code>set</code> —— 写入属性时抛出错误</li><li><code>deleteProperty</code> —— 删除属性时抛出错误</li><li><code>ownKeys</code> —— 在使用 <code>for..in</code> 和类似 <code>Object.keys</code> 的方法时排除以 <code>_</code> 开头的属性</li></ul><p>代码如下：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  _password<span class="token operator">:</span> <span class="token string">&#39;******&#39;</span>
<span class="token punctuation">}</span>

user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//拦截读取操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Access denied&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value <span class="token comment">// (1)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截写入操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Access denied&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> val
      <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// 记得返回 true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截属性删除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Access denied&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// 记得返回 true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 拦截读取属性列表</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;_&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// “get” 不允许读取 _password</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>_password<span class="token punctuation">)</span> <span class="token comment">// Error: Access denied</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token comment">//  “set” 不允许写入 _password</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  user<span class="token punctuation">.</span>_password <span class="token operator">=</span> <span class="token string">&quot;test&quot;</span> <span class="token comment">// Error: Access denied</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token comment">// “deleteProperty” 不允许删除 _password 属性</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">delete</span> user<span class="token punctuation">.</span>_password <span class="token comment">// Error: Access denied</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token comment">// “ownKeys” 过滤排除 _password</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// name</span>
</code></pre></div><p>请注意在 (1) 中 <code>get</code> 钩子的重要细节：</p><div class="language-js"><pre><code><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value
<span class="token punctuation">}</span>
</code></pre></div><p>为什么我们需要做一个函数作用域绑定 <code>value.bind(target)</code>，原因是，虽然我们不能从外部直接访问对象内部私用属性，但是对象自带的方法却不应该受限制。例如假设，<code>user</code> 对象有个 <code>checkPassword</code> 方法：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">checkPassword</span><span class="token punctuation">(</span><span class="token parameter">password</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> password <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_checkPassword
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
</code></pre></div><p>如果不进行（1）中的作用域绑定，<code>user</code> 经行代理之后，访问 <code>user.checkPassword</code> 时，<code>checkPassword</code> 方法内部的 <code>this</code> 指向的是代理之后的对象（<code>.</code>之前的对象），这时访问 <code>this._password</code> 将会被 <code>get</code> 钩子拦截，并抛出错误。这不是我们想要的结果，我们希望对象方法能够正常访问 <code>_password</code>，所以需要在 <code>get</code> 钩子中做一下判断，如果访问的属性是一个方法（function）, 则将它的 <code>this</code> 绑定到目标对象上，这样它就可以绕过代理的拦截。</p><p>该解决方案通常可行，但并不理想，如果我们将未代理的原目标对象传给了方法，那对象方法可能会将它传递到其它地方，这样就会引起混乱：哪个是原始对象，哪个是目标对象。而且，一个对象可能会被代理多次（多个代理可能会对该对象添加不同的“调整”），产生意想不到的后果。</p><p>因此，在任何地方都不应使用这种代理。现代 Javascript 引擎原生支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" target="_blank" rel="noopener noreferrer">类私有属性</a>，以 <code>#</code> 作为前缀, 所以 <code>Proxy</code> 并不是必需的。</p><h3 id="使用-has-钩子拦截属性检查" tabindex="-1">使用 <code>has</code> 钩子拦截属性检查 <a class="header-anchor" href="#使用-has-钩子拦截属性检查" aria-hidden="true">#</a></h3><p>用 <code>has</code> 钩子拦截 <code>in</code> 操作符，对应的钩子为 <code>has(target, property)</code>：</p><ul><li><code>target</code> —— 是目标对象，作为第一个参数传递给 <code>new Proxy</code></li><li><code>property</code> —— 属性名称</li></ul><p>假设有一个 <code>range</code> 对象, 我们想使用 <code>in</code> 操作符来检查数字是否在 <code>range</code> 范围内：</p><div class="language-js"><pre><code><span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token punctuation">{</span>
  start<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  end<span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span>
range <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>range<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> prop <span class="token operator">&gt;=</span> target<span class="token punctuation">.</span>start <span class="token operator">&amp;&amp;</span> prop <span class="token operator">&lt;=</span> target<span class="token punctuation">.</span>end
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token keyword">in</span> range<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">50</span> <span class="token keyword">in</span> range<span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>漂亮的语法糖，不是吗？而且实现起来非常简单！</p><h3 id="使用-apply-钩子代理函数调用" tabindex="-1">使用 <code>apply</code> 钩子代理函数调用 <a class="header-anchor" href="#使用-apply-钩子代理函数调用" aria-hidden="true">#</a></h3><p><code>apply(target, thisArg, args)</code> 钩子能使代理以函数的方式被调用：</p><ul><li><code>target</code> —— 目标函数</li><li><code>thisArg</code> —— <code>this</code> 的值</li><li><code>args</code> —— 参数列表</li></ul><p>用 <code>Proxy</code> 实现延时装饰者：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> ms</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> thisArg<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">target</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

sayHi <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//1 代理上的所有操作都转发到原始函数</span>

<span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span> <span class="token comment">// Hello, John! （3秒后）</span>
</code></pre></div><h2 id="reflect" tabindex="-1">Reflect <a class="header-anchor" href="#reflect" aria-hidden="true">#</a></h2><p><code>Reflect</code> 是一个内置对象，可简化的创建 <code>Proxy</code></p><p>以前的内部方法，比如 <code>[[Get]]</code>，<code>[[Set]]</code> 等等都只是规范，不能直接调用。<code>Reflect</code> 对象使调用这些内部方法成为可能，它的方法是内部方法的最小包装：</p><table><thead><tr><th style="text-align:center;">操作</th><th style="text-align:center;">Reflect 调用</th><th style="text-align:center;">内部方法</th></tr></thead><tbody><tr><td style="text-align:center;">obj[prop]</td><td style="text-align:center;">Reflect.get(obj, prop)</td><td style="text-align:center;">[[Get]]</td></tr><tr><td style="text-align:center;">obj[prop] = value</td><td style="text-align:center;">Reflect.set(obj, prop, value)</td><td style="text-align:center;">[[Set]]</td></tr><tr><td style="text-align:center;">delete obj[prop]</td><td style="text-align:center;">Reflect.deleteProperty(obj, prop)</td><td style="text-align:center;">[[Delete]]</td></tr><tr><td style="text-align:center;">new F(value)</td><td style="text-align:center;">Reflect.construct(F, value)</td><td style="text-align:center;">[[Construct]]</td></tr><tr><td style="text-align:center;">...</td><td style="text-align:center;">...</td><td style="text-align:center;">...</td></tr></tbody></table><p>这是 Reflect 执行相同操作和调用的示例：</p><div class="language-js"><pre><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// John</span>
</code></pre></div><p>对于每个可被 <code>Proxy</code> 捕获的内部方法，<code>Reflect</code> 都有一个对应的方法进行反射（reflect），其名称和参数与 <code>Proxy</code> 钩子相同。因此，我们可以用 <code>Reflect</code> 来将操作转发到原始对象。</p><p>在下面的例子中，钩子 <code>get</code> 和 <code>set</code> 透明地将读/写操作转发到对象，并显示一条消息：</p><div class="language-js"><pre><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span>
<span class="token punctuation">}</span>

user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">GET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token comment">// (1)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token comment">// (2)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> name <span class="token operator">=</span> user<span class="token punctuation">.</span>name <span class="token comment">// shows &quot;GET name&quot;</span>
user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Pete&quot;</span> <span class="token comment">// shows &quot;SET name=Pete&quot;</span>
</code></pre></div><p>这里：</p><ul><li><code>Reflect.get</code> 读取一个对象属性</li><li><code>Reflect.set</code> 写入对象属性，成功返回 <code>true</code> ，否则返回 <code>false</code></li></ul><p>就是说，一切都很简单：如果钩子想要将调用转发给原始对象，则只需使用相同的参数调用 <code>Reflect.&lt;method&gt;</code> 就足够了。</p><p>在大多数情况下，我们不使用 <code>Reflect</code> 也可以完成相同的事情，例如，使用 <code>Reflect.get(target, prop, receiver)</code> 读取属性可以替换为 <code>target[prop]</code>，尽管有一些细微的差别。</p><h3 id="代理一个-getter" tabindex="-1">代理一个 getter <a class="header-anchor" href="#代理一个-getter" aria-hidden="true">#</a></h3><p>让我们看一个示例，说明为什么 <code>Reflect.get</code> 更好。我们还将看到为什么 <code>get/set</code> 有第四个参数 <code>receiver</code>，而我们以前没有使用过它。</p><p>我们有一个带有一个 <code>_name</code> 属性和一个 <code>getter</code> 的对象 <code>user</code> 对象：</p><div class="language-js"><pre><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  _name<span class="token operator">:</span> <span class="token string">&#39;Guest&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userProxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// Guest</span>
</code></pre></div><p>这个 <code>get</code> 钩子在这里是透明的，它返回原来的属性，不会做别的任何事情，对于我们的示例而言，这就足够了。</p><p>但是让我们将示例变得更加复杂：</p><div class="language-js"><pre><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  _name<span class="token operator">:</span> <span class="token string">&#39;Guest&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token comment">// (1) target = user</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>
  __proto__<span class="token operator">:</span> userProxy<span class="token punctuation">,</span>
  _name<span class="token operator">:</span> <span class="token string">&#39;Admin&#39;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Expected: Admin</span>
<span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 输出：Guest （？！？）</span>
</code></pre></div><p>另一个对象 <code>admin</code> 从 <code>user</code> 继承后，我们可以观察到错误的行为，读取 <code>admin.name</code> 应该返回 <code>&#39;Admin&#39;</code>，而不是 <code>&#39;Guest&#39;</code>。</p><p>问题出现在（1）中：</p><ol><li>当我们读取 <code>admin.name</code>，由于 <code>admin</code> 对象自身没有对应的的属性，搜索将转到其原型上。</li><li>原型是 <code>userProxy</code></li><li>从代理读取 <code>name</code> 属性时，<code>get</code> 钩子会触发并从原始对象返回 <code>target[prop]</code></li><li>当调用 <code>target[prop]</code> 时，若 <code>prop</code> 是一个 getter，它将在 this=target 上下文中运行其代码。因此，结果是来自原始对象 <code>target</code> （即 <code>user</code>）的 <code>this._name</code></li></ol><p>为了解决这种问题，我们需要用到 <code>get</code> 钩子的第三个参数 <code>receiver</code>。它保证传递正确的 <code>this</code> 给 <code>getter</code>。那如何为 <code>getter</code> 传递上下文呢？对于常规函数，我们可以使用 <code>call/apply</code>，但这是一个 <code>getter</code>，它不能被调用的，只能被访问。</p><p><code>Reflect.get</code> 可以做到，如果我们使用它，一切都会正常运行：</p><div class="language-js"><pre><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  _name<span class="token operator">:</span> <span class="token string">&#39;Guest&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token comment">// (1) target = admin</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>
  __proto__<span class="token operator">:</span> userProxy<span class="token punctuation">,</span>
  _name<span class="token operator">:</span> <span class="token string">&#39;Admin&#39;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Expected: Admin</span>
<span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 输出：Admin （？！？）</span>
</code></pre></div><p>现在 <code>receiver</code> 保留了对正确 <code>this</code> 的引用，该引用将在 (1) 行中使用 <code>Reflect.get</code> 传递给 <code>getter</code>。</p><p><code>Reflect</code> 调用的命名方式与 <code>Proxy</code> 钩子完全相同，并且接受相同的参数。因此我们可以将钩子重写得更短：</p><div class="language-js"><pre><code><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Reflect</code> 提供了一种安全的方式来转发操作，确保我们不会忘记与此相关的任何内容。</p><h2 id="proxy-的局限" tabindex="-1">Proxy 的局限 <a class="header-anchor" href="#proxy-的局限" aria-hidden="true">#</a></h2><p>代理提供了一种独特的方法，可以在最底层更改或调整现有对象的行为。但是，它并不完。</p><h3 id="内部插槽（internal-slots）" tabindex="-1">内部插槽（Internal slots） <a class="header-anchor" href="#内部插槽（internal-slots）" aria-hidden="true">#</a></h3><p>许多内置对象，例如 <code>Map</code>, <code>Set</code>, <code>Date</code>, <code>Promise</code> 等等都使用了所谓的 “内部插槽”。它们类似于属性，但仅限于内部使用，仅用于规范目的。例如， <code>Map</code> 将项目存储在 <code>[[MapData]]</code> 中。内置方法直接访问它们，而不通过 <code>[[Get]]/[[Set]]</code> 内部方法。</p><p>这就是问题。在像这样的内置对象被代理后，代理对象没有这些内部插槽，因此内置方法将失败。</p><div class="language-js"><pre><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

proxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// Error</span>
</code></pre></div><p>在内部，一个 <code>Map</code> 将所有数据存储在其 <code>[[MapData]]</code> 内部插槽中。代理对象没有这样的插槽。内建方法 <code>Map.prototype.set</code> 方法试图访问内部属性 <code>this.[[MapData]]</code>，但由于 this=proxy 在，而 <code>proxy</code> 中不能找到它，只能失败。</p><p>幸运的是，有一种解决方法：</p><div class="language-js"><pre><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">==</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

proxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1 (works!)</span>
</code></pre></div><p>现在它可以正常工作，因为 <code>get</code> 钩子将函数属性（例如 <code>map.set</code>）绑定到目标对象（<code>map</code>）本身，因此，当 <code>set</code> 钩子的内部实现尝试访问 <code>this.[[MapData]]</code> 内部插槽时，它会成功。</p><h3 id="私有字段" tabindex="-1">私有字段 <a class="header-anchor" href="#私有字段" aria-hidden="true">#</a></h3><p>类的私有字段也会发生类似的情况。</p><p>例如，<code>getName()</code> 方法访问私有的 <code>#name</code> 属性会在代理后中断：</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  #name <span class="token operator">=</span> <span class="token string">&quot;Guest&quot;</span>

  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Error</span>
</code></pre></div><p>原因是专用字段是使用内部插槽实现的。JavaScript 访问它们时不使用 <code>[[Get]]/[[Set]]</code>。在调用 <code>getName()</code> 时 <code>this</code> 的值是代理后的 <code>user</code>，它没有带私有字段的插槽。</p><p>再次，使用 <code>bind</code> 方法的可以使它恢复正常：</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  #name <span class="token operator">=</span> <span class="token string">&quot;Guest&quot;</span>

  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">==</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Guest</span>
</code></pre></div><p>该解决方案也有缺点：将原始对象暴露给方法，可能使其进一步传递并破坏其他代理功能。</p><h2 id="可取消的-proxy" tabindex="-1">可取消的 Proxy <a class="header-anchor" href="#可取消的-proxy" aria-hidden="true">#</a></h2><p>假设我们有一个资源，并且想随时关闭对该资源的访问 我们可以做的是将其包装成可撤销的代理，而没有任何钩子。这样的代理会将操作转发给对象，我们可以随时将其禁用。语法：</p><div class="language-js"><pre><code><span class="token keyword">const</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
</code></pre></div><p>一个例子：</p><div class="language-js"><pre><code><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token string">&quot;Valuable data&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// proxy 正常工作</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// Valuable data</span>

<span class="token function">revoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// proxy 不再工作（已销毁）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// Error</span>
</code></pre></div><p>调用 <code>revoke()</code> 会从代理中删除对目标对象的所有内部引用，因此不再连接它们。之后可以对目标对象进行垃圾回收。</p><p>我们还可以将 <code>revoke</code> 存储在 <code>WeakMap</code> 中，以便能够通过代理对象轻松找到它：</p><div class="language-js"><pre><code><span class="token keyword">const</span> revokes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token string">&quot;Valuable data&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

revokes<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> revoke<span class="token punctuation">)</span>

<span class="token comment">// 之后...</span>
revoke <span class="token operator">=</span> revokes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span>
<span class="token function">revoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// Error</span>
</code></pre></div><p>这种方法的好处是我们不必随身携带 <code>revoke</code>。我们可以在需要时从 map 上获取它</p><p>这里使用 <code>WeakMap</code> 而不是 <code>Map</code> ，是因为 <code>WeakMap</code> 不会阻止垃圾回收。如果代理对象变得“无法访问”（例如，没有变量再引用它），则 <code>WeakMap</code> 允许将其与它的 <code>revoke</code> 对象一起从内存中删除，因为我们不再需要它了。</p><h2 id="几个用例" tabindex="-1">几个用例 <a class="header-anchor" href="#几个用例" aria-hidden="true">#</a></h2><h3 id="数组负索引" tabindex="-1">数组负索引 <a class="header-anchor" href="#数组负索引" aria-hidden="true">#</a></h3><p>像这样：</p><div class="language-js"><pre><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>

array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 3</span>
array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">// 2</span>
array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">// 1</span>
</code></pre></div><p>换句话说，<code>array[-n]</code> 与 <code>array[array.length - n]</code> 相同。</p><p>用 Proxy 实现起来很简单：</p><div class="language-js"><pre><code><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>

array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// prop 是 string, 需要先将它转换成 number </span>
      prop <span class="token operator">=</span> <span class="token operator">+</span>prop <span class="token operator">+</span> target<span class="token punctuation">.</span>length
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 3</span>
array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">// 2</span>
array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">// 1</span>
</code></pre></div><h3 id="observable" tabindex="-1">Observable <a class="header-anchor" href="#observable" aria-hidden="true">#</a></h3><p>实现一个使对象可观察的函数 <code>makeObservable(target)</code>：</p><div class="language-js"><pre><code><span class="token keyword">const</span> handlers <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&#39;handlers&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">makeObservable</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//  初始化 handler 存储数组</span>
  target<span class="token punctuation">[</span>handlers<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token comment">// 存储 handler 函数到数组中以便于未来调用</span>
  target<span class="token punctuation">.</span><span class="token function-variable function">observe</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">[</span>handlers<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 创建代理</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> success <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token comment">// 转发写入操作到目标对象</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果设置属性的时候没有报错</span>
        <span class="token comment">// 调用所有 handler</span>
        target<span class="token punctuation">[</span>handlers<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">handler</span> <span class="token operator">=&gt;</span> <span class="token function">handler</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> success
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

user <span class="token operator">=</span> <span class="token function">makeObservable</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>

user<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;John&quot;</span> <span class="token comment">// SET name=John</span>
</code></pre></div></div></div><footer class="page-footer" data-v-8fcebc32 data-v-5c96fb00><div class="edit" data-v-5c96fb00><div class="edit-link" data-v-5c96fb00 data-v-55695e90><!----></div></div><div class="updated" data-v-5c96fb00><!----></div></footer><div class="next-and-prev-link" data-v-8fcebc32 data-v-e65a9748><div class="container" data-v-e65a9748><div class="prev" data-v-e65a9748><a class="link" href="/yangss/articles/effective-ts" data-v-e65a9748><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-e65a9748><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-e65a9748>Effective TypeScript</span></a></div><div class="next" data-v-e65a9748><a class="link" href="/yangss/articles/settimeout-setinterval" data-v-e65a9748><span class="text" data-v-e65a9748>setTimeout 和 setInterval</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-e65a9748><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"readme.md\":\"2816ac88\",\"articles_async-setup.md\":\"f7658c48\",\"articles_currying.md\":\"cc93a4a2\",\"articles_decorator.md\":\"2d5460cf\",\"articles_effective-ts.md\":\"b4c1c60c\",\"articles_index.md\":\"41d4410e\",\"articles_proxy-reflect.md\":\"02419337\",\"articles_settimeout-setinterval.md\":\"06460a6e\",\"articles_switch-true-pattern.md\":\"e4f2aa6d\",\"articles_weakmap-weakset.md\":\"9f5621e4\",\"bookmarks.md\":\"dff3c5d3\",\"index.md\":\"46a9e6f6\",\"notes_git.md\":\"e8faa351\",\"notes_index.md\":\"24a93f06\",\"notes_linux.md\":\"2b3ff8e9\",\"notes_nginx.md\":\"98dd1b7b\",\"notes_package-json.md\":\"963a0c44\",\"notes_regexp.md\":\"662ffe8b\",\"notes_type-challenges.md\":\"cdba6574\",\"notes_typescript.md\":\"2dbc0ca5\",\"projects.md\":\"a8d5ad20\"}")</script>
    <script type="module" async src="/yangss/assets/app.b2baf6b4.js"></script>
    
  </body>
</html>