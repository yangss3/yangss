<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入理解 CORS | YangSS</title>
    <meta name="description" content="Nicholas Yang's personal blog.">
    <link rel="stylesheet" href="/yangss/assets/style.986d0184.css">
    <link rel="modulepreload" href="/yangss/assets/Home.5cd24a4a.js">
    <link rel="modulepreload" href="/yangss/assets/app.04efe956.js">
    <link rel="modulepreload" href="/yangss/assets/articles_understand-cors.md.2590d5a3.lean.js">
    <link rel="modulepreload" href="/yangss/assets/app.04efe956.js">
    <meta name="twitter:title" content="深入理解 CORS | YangSS">
    <meta property="og:title" content="深入理解 CORS | YangSS">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/yangss/" aria-label="YangSS, back to home" data-v-40587210 data-v-7ac13a1e><!----> YangSS</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item active" href="/yangss/articles/" data-v-49fe041d>Articles <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/notes/" data-v-49fe041d>Notes <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/projects" data-v-49fe041d>Projects <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--[--><div class="flex space-x-5 ml-5"><button class="icon-button" title="Bookmarks" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24"><path d="M17 18l-5-2.18L7 18V5h10m0-2H7a2 2 0 0 0-2 2v16l7-3l7 3V5a2 2 0 0 0-2-2z" fill="currentColor"></path></svg><!--]--></button><button class="icon-button" title="GitHub" data-v-5dee39e6><a href="https://github.com/yangss3" target="_blank" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24"><path fill="currentColor" d="M16.24 22a1 1 0 0 1-1-1v-2.6a2.15 2.15 0 0 0-.54-1.66a1 1 0 0 1 .61-1.67C17.75 14.78 20 14 20 9.77a4 4 0 0 0-.67-2.22a2.75 2.75 0 0 1-.41-2.06a3.71 3.71 0 0 0 0-1.41a7.65 7.65 0 0 0-2.09 1.09a1 1 0 0 1-.84.15a10.15 10.15 0 0 0-5.52 0a1 1 0 0 1-.84-.15a7.4 7.4 0 0 0-2.11-1.09a3.52 3.52 0 0 0 0 1.41a2.84 2.84 0 0 1-.43 2.08a4.07 4.07 0 0 0-.67 2.23c0 3.89 1.88 4.93 4.7 5.29a1 1 0 0 1 .82.66a1 1 0 0 1-.21 1a2.06 2.06 0 0 0-.55 1.56V21a1 1 0 0 1-2 0v-.57a6 6 0 0 1-5.27-2.09a3.9 3.9 0 0 0-1.16-.88a1 1 0 1 1 .5-1.94a4.93 4.93 0 0 1 2 1.36c1 1 2 1.88 3.9 1.52a3.89 3.89 0 0 1 .23-1.58c-2.06-.52-5-2-5-7a6 6 0 0 1 1-3.33a.85.85 0 0 0 .13-.62a5.69 5.69 0 0 1 .33-3.21a1 1 0 0 1 .63-.57c.34-.1 1.56-.3 3.87 1.2a12.16 12.16 0 0 1 5.69 0c2.31-1.5 3.53-1.31 3.86-1.2a1 1 0 0 1 .63.57a5.71 5.71 0 0 1 .33 3.22a.75.75 0 0 0 .11.57a6 6 0 0 1 1 3.34c0 5.07-2.92 6.54-5 7a4.28 4.28 0 0 1 .22 1.67V21a1 1 0 0 1-.94 1z"></path></svg><!--]--></a></button><button class="icon-button" data-v-5dee39e6><!--[--><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24" style="display:none;"><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938A7.999 7.999 0 0 0 4 12z" fill="currentColor"></path></svg><svg class="relative top-2px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24" style=""><path d="M12 18a6 6 0 1 1 0-12a6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636L5.636 7.05L3.515 4.93zM16.95 18.364l1.414-1.414l2.121 2.121l-1.414 1.414l-2.121-2.121zm2.121-14.85l1.414 1.415l-2.121 2.121l-1.414-1.414l2.121-2.121zM5.636 16.95l1.414 1.414l-2.121 2.121l-1.414-1.414l2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z" fill="currentColor"></path></svg><!--]--></button></div><!--]--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item active" href="/yangss/articles/" data-v-49fe041d>Articles <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/notes/" data-v-49fe041d>Notes <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/yangss/projects" data-v-49fe041d>Projects <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-17c48e2f><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/switch-true-pattern">妙用 switch(true)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/what-is-blob">Blob 是什么？</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/understand-arraybuffer">深入理解 ArrayBuffer 和 TypedArray</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/understand-weakmap-and-weakset">深入理解 WeakMap 和 WeakSet</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/yangss/articles/understand-cors">深入理解 CORS</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#为什么需要-cors">为什么需要 CORS</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#安全请求">安全请求</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#不安全的请求">不安全的请求</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#凭据-credentials">凭据 (Credentials)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#总结">总结</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/async-setup">异步 setup</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/understand-unknown-in-typescript">深入理解 TypeScript 中的 unknown</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/excess-property-checking-in-typescript">TypeScript 中的超出属性检查 (Excess property checking)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/how-context-is-used-in-typescript">理解上下文 (Context) 在类型推断中的作用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/understand-ts-type-system">深入理解 TypeScript 的类型系统</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/explaining-proxy-and-reflect-in-detail">详解 Proxy 和 Reflect</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/what-is-currying">什么是柯里化 (Currying)？</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/settimeout-setinterval">setTimeout 和 setInterval</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yangss/articles/what-is-decorator-pattern">什么是装饰者模式？</a><!----></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="深入理解-cors" tabindex="-1">深入理解 CORS <a class="header-anchor" href="#深入理解-cors" aria-hidden="true">#</a></h1><p class="text-gray-400 dark:text-gray-600 flex items-center space-x-2 mb-24px"><svg class="relative top-2px !top-1px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveaspectratio="xMidYMid meet" viewbox="0 0 48 48"><g fill="none" stroke="currentColor" stroke-width="4" stroke-linejoin="round"><path d="M5 19h38v21a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V19z"></path><path d="M5 9a2 2 0 0 1 2-2h34a2 2 0 0 1 2 2v10H5V9z"></path><path d="M16 4v8" stroke-linecap="round"></path><path d="M32 4v8" stroke-linecap="round"></path><path d="M28 34h6" stroke-linecap="round"></path><path d="M14 34h6" stroke-linecap="round"></path><path d="M28 26h6" stroke-linecap="round"></path><path d="M14 26h6" stroke-linecap="round"></path></g></svg><span>2021/10/22</span></p><p>跨源资源共享（Cross Origin Resource Sharing）简称 CORS，是一种基于 HTTP 头的安全机制，它允许服务器指定除其自身以外的任何源 Origin (protocol/domain/port)，并让浏览器允许从这些源加载资源。</p><h2 id="为什么需要-cors" tabindex="-1">为什么需要 CORS <a class="header-anchor" href="#为什么需要-cors" aria-hidden="true">#</a></h2><p>出于安全考虑，一般情况下，浏览器是不允许跨源请求 (cross-origin request) 的，即来自 <code>https://domain-a.com</code> 的客户端代码无法对 <code>https://domain-b.com</code> 的资源发起网络请求 (通过 <code>XMLHttpRequest</code> 或 <code>Fetch</code> API)，这样可以保护互联网免受邪恶黑客的攻击。</p><p>但是，随着 web 应用变得越来越复杂，跨源请求是很常见的需求。为了突破浏览器的限制，早期出现了很多跨域的方案，最常见的就是 JSONP (JSON with padding)。</p><p>JSONP 利用了 <code>&lt;script&gt;</code> 标签的 <code>src</code> 可以是任何源 (origin)，即它可以执行来自任何网站的脚本的特点，来实现跨源资源共享。</p><p>假设我们的站点 <code>https://my-website.com</code> 需要从 <code>https://weather.com</code> 获取天气数据，可以这样做：</p><ol><li>首先，我们事先声明一个全局函数来接受数据，例如 <code>getWeather</code>：<div class="language-js"><pre><code><span class="token comment">// 定义一个全局函数用于处理天气数据</span>
<span class="token keyword">function</span> <span class="token function">getWeather</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> temperature<span class="token punctuation">,</span> humidity <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">temperature: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>temperature<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, humidity: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>humidity<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li>然后，我们创建一个 <code>&lt;script&gt;</code> 标签， 并设置 <code>src=&quot;http://weather.com/?callback=getWeather&quot;</code>，使用我们预先定义好的函数名定义一个 URL 参数 <code>callback</code>：<div class="language-js"><pre><code><span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;script&#39;</span><span class="token punctuation">)</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&#39;http://weather.com/?callback=getWeather&#39;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
</code></pre></div></li><li>远程服务器 <code>weather.com</code> 在接收到这个请求后，动态地生成一个脚本，脚本内部使用它想让我们接收的数据调用 <code>getWeather(...)</code>：<div class="language-js"><pre><code><span class="token comment">// weather.com 返回的脚本内容类似这样:</span>
<span class="token function">getWeather</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  temperature<span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>
  humidity<span class="token operator">:</span> <span class="token number">78</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li><li>当我们的站点加载和并执行响应回来的脚本时，<code>getWeather</code> 就会运行，因为这是我们预先定义好的全局函数，所以我们就拿到了数据。</li></ol><p>这种方法是可行的，而且不违反浏览器的安全策略，因为这样做的前提是双方都同意以这种方式传递数据。所以这绝不是一个黑客。现在仍然有提供这种访问的服务，因为它支持非常古老的浏览器版本。</p><p>但是 JSONP 也有很多缺点，例如只能行进 GET 请求，无法处理错误等等。为了能安全有效的解决这些问题，CORS 就出现了，它允许在满足特定的条件的情况下，通过 <code>XMLHttpRequest</code> 或 <code>Fetch</code> API 进行跨源请求。</p><h2 id="安全请求" tabindex="-1">安全请求 <a class="header-anchor" href="#安全请求" aria-hidden="true">#</a></h2><p>总的来说，跨源请求 (cross-origin request) 可以分为两类：</p><ol><li>全安请求</li><li>其它所有请求</li></ol><p>什么是安全请求 (safe request) ？如果一个请求同时满足下面两个条件，我们称它是安全的：</p><ol><li>请求方法是 GET, POST, HEAD 之一</li><li>只能包含如下的自定义请求头： <ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code>，且值只能是 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code> 之一</li></ul></li></ol><p>任何不满足这两个条件的请求都被认为是不安全的。</p><p>其本质区别在于，安全请求可以用 <code>&lt;form&gt;</code> 或 <code>&lt;script&gt;</code> 来实现，不需要用到任何特殊方法。所以一个古老的服务器也可以处理安全请求。</p><p>与此相反，带有非标准头的请求或例如 DELETE 请求都不能用这种方式创建。很长时间以来，JavaScript 都不能发送这样的请求。因此，一个古老的服务器可能会认为这样的请求来自于一个有特权的来源，因为一个网页无法发送这些请求。</p><p>当我们试图发送一个不安全的请求时，浏览器会先发送一个特殊的 &quot;预检&quot; (preflight) 请求来询问服务器是否同意接受这种跨源请求？除非服务器响应明确的 CORS 头信息进行确认，否则浏览器不会发送不安全的请求。</p><p>如果一个请求是跨源的 (cross-origin)，浏览器会给它加上 <code>Origin</code> 头，例如，如果我们从 <code>https://website-a.com/page</code> 发起请求 <code>https://website-b.com/request</code>，请求头将是这样：</p><div class="language-http"><pre><code>GET /request
<span class="token header-name keyword">Host:</span> website-b.com
<span class="token header-name keyword">Origin:</span> https://website-a.com
...
</code></pre></div><p>服务器会检查 <code>Origin</code> 头信息，如果它同意接受这样的请求，就在响应中添加一个特殊的头<code>Access-Control-Allow-Origin</code>。该响应头应包含允许的源 (origin)，在我们的例子中是 <code>https://website-a.com</code> ，或者一个星号 <code>*</code>，那么请求就会成功，否则将抛出错误。</p><p>浏览器在这个过程种扮演类似调解人的角色：</p><ol><li>它确保跨源请求发送正确的 <code>Origin</code> 头。</li><li>它检查响应头 <code>Access-Control-Allow-Origin</code> 中是否包含请求源，如果它存在，则允许 JavaScript 访问响应 (response)，否则抛出错误。</li></ol><p>下面是一个成功的服务端响应头：</p><div class="language-http"><pre><code>200 OK
<span class="token header-name keyword">Content-Type:</span>text/html; charset=UTF-8
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> https://website-a.com
</code></pre></div><p>对于跨源请求，默认情况下只允许 JavaScript 访问“安全”的响应头：</p><ul><li><code>Cache-Control</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code></li><li><code>Expires</code></li><li><code>Last-Modified</code></li><li><code>Pragma</code></li></ul><p>除此之外，访问任何其它响应头都会报错。</p><p>要授予 JavaScript 对其他响应头的访问权，服务器必须发送<code>Access-Control-Expose-Headers</code> 头，并在其中指明以逗号分隔的不安全头名称列表。例如：</p><div class="language-http"><pre><code>200 OK
<span class="token header-name keyword">Content-Type:</span>text/html; charset=UTF-8
<span class="token header-name keyword">Content-Length:</span> 12345
<span class="token header-name keyword">API-Key:</span> 2c9de507f2c54aa1
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> https://website-a.com
<span class="token header-name keyword">Access-Control-Expose-Headers:</span> Content-Length,API-Key
</code></pre></div><p>有了这样的 <code>Access-Control-Expose-Headers</code> 响应头，JavaScript 脚本就可以读取响应中的 <code>Content-Length</code> 和 <code>API-Key</code> 头。</p><h2 id="不安全的请求" tabindex="-1">不安全的请求 <a class="header-anchor" href="#不安全的请求" aria-hidden="true">#</a></h2><p>请求方法除了 <code>GET</code>，<code>Post</code>, 还可以是 <code>PATCH</code>，<code>DELETE</code> 等等。在过去，是无法通过网页发送这种请求的，所以一些古老的 web 服务器在接收到这种请求时，它们会认为：这一定不是来自浏览器。为了避免这种误解，对于这些“不安全”的请求，浏览器不会立刻将其直接发送给服务器，而是先发送一个“预检” (preflight) 请求，向服务器询问权限。</p><p>预检请求通过 <code>OPTIONS</code> 方法发送，且不携带 body，只包含三个请求头：</p><ul><li><code>Access-Control-Request-Method</code>：指明不安全请求的方法</li><li><code>Access-Control-Request-Headers</code>：逗号分隔的不安全的请求头列表</li><li><code>Origin</code>：请求源，指明不安全请求来自哪里</li></ul><p>如果服务器同意服务这个请求，它应该响应空的body，200 状态码和如下响应头：</p><ul><li><code>Access-Control-Allow-Origin</code>：允许的请求源，例如 <code>https://website-a.com</code>, 或是一个星号 <code>*</code> 表明允许任何源</li><li><code>Access-Control-Allow-Methods</code>：允许的请求方法</li><li><code>Access-Control-Allow-Headers</code>：允许的请求头</li><li><code>Access-Control-Max-Age</code>：可以指定一个缓存权限的时间长度 (秒数)。这样，浏览器就不必为满足给定权限的后续请求发送预检。</li></ul><p>下面以一个跨源的 <code>PATCH</code> 请求为例，看看它是如何一步步工作的：</p><div class="language-js"><pre><code><span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://website-b.com/request&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  method<span class="token operator">:</span> <span class="token string">&#39;PATCH&#39;</span><span class="token punctuation">,</span>
  headers<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;Content-Type&#39;</span><span class="token operator">:</span> <span class="token string">&#39;application/json&#39;</span><span class="token punctuation">,</span>
    <span class="token string">&#39;API-Key&#39;</span><span class="token operator">:</span> <span class="token string">&#39;secret&#39;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>有三个原因导致该请求不安全（只要一个就够了）:</p><ul><li>请求方法 <code>PATCH</code></li><li><code>Content-Type</code> 不是 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code> 之一</li><li>不安全的 <code>API-Key</code> 头</li></ul><p><strong>第一步：浏览器发送预检请求</strong></p><p>在发送真正的请求之前，浏览器会先发送一个 <code>OPTIONS</code> 预检请求，请求头如下：</p><div class="language-http"><pre><code>OPTIONS /request
<span class="token header-name keyword">Host:</span> website-b.com
<span class="token header-name keyword">Origin:</span> https://website-a.com
<span class="token header-name keyword">Access-Control-Request-Method:</span> PATCH
<span class="token header-name keyword">Access-Control-Request-Headers:</span> Content-Type,API-Key
</code></pre></div><ul><li>请求方法：<code>OPTIONS</code></li><li>请求路径：<code>/request</code></li><li>跨源的特殊的请求头： <ul><li><code>Origin</code>：请求源</li><li><code>Access-Control-Request-Method</code>：不安全的请求方法</li><li><code>Access-Control-Request-Headers</code>：不安全的请求头列表</li></ul></li></ul><p><strong>第二步：服务器响应预检请求</strong></p><p>服务器以状态码 200 发送如下响应头：</p><div class="language-http"><pre><code>200 OK
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> https://website-a.com/page
<span class="token header-name keyword">Access-Control-Allow-Methods:</span> PATCH
<span class="token header-name keyword">Access-Control-Allow-Headers:</span> Content-Type,API-Key
</code></pre></div><p>这意味着服务器允许后面的 <code>PATCH</code> 请求。</p><p>如果服务器允许后面有其它方法的请求 (<code>PUT</code>, <code>DELETE</code> 等)或可携带其它头信息，可以提前允许它们，只要将它们添加到列表中即可，例如：</p><div class="language-"><pre><code>200 OK
Access-Control-Allow-Origin: https://website-a.com/page
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400
</code></pre></div><p>浏览器拿到预检响应后，看到 <code>PATCH</code> 在 <code>Access-Control-Allow-Methods</code> 中，<code>Content-Type</code>，<code>API-Key</code> 在 <code>Access-Control-Allow-Headers</code> 列表中，所以它发出了主请求。</p><p>响应头中如果有带秒数的 <code>Access-Control-Max-Age</code>，那么该预检的权限就会被缓存给定的时间。例如上面的响应将被缓存 86400 秒 (一天)。在这个时间范围内，后续满足条件的请求将不会触发预检，而是被直接发送。</p><p><strong>第三步：浏览器发送主请求</strong></p><p>当预检请求成功后，浏览器会进行主请求。这里的过程与安全请求的过程是一样的：</p><div class="language-http"><pre><code>PATCH /request
<span class="token header-name keyword">Host:</span> website-b.com
<span class="token header-name keyword">Origin:</span> https://website-a.com
<span class="token header-name keyword">Content-Type:</span> application/json
<span class="token header-name keyword">API-Key:</span> secret
</code></pre></div><p><strong>第四步：服务器响应主请求</strong></p><p>服务器在主响应中需要添加 <code>Access-Control-Allow-Origin</code>：</p><div class="language-http"><pre><code><span class="token header-name keyword">Access-Control-Allow-Origin:</span> https://website-a.com
</code></pre></div><p>这样，JavaScript 才可以访问到主请求的响应。</p><div class="tip custom-block"><p class="custom-block-title">注意</p><p>预检请求发生在 &quot;幕后&quot;，它对 JavaScript 是不可见的。JavaScript 只能访问对主请求的响应，如果没有得到服务器的许可，则会抛出一个错误。</p></div><h2 id="凭据-credentials" tabindex="-1">凭据 (Credentials) <a class="header-anchor" href="#凭据-credentials" aria-hidden="true">#</a></h2><p>通常情况下，对 <code>http://website-b.com</code> 的发起的请求会携带该域的所有 cookies。但由 JavaScript 发出的跨源请求是一个例外。默认情况下，由 JavaScript 发起的跨源请求不会携带任何 <em>credentials</em> (cookies 或 HTTP authentication)。</p><p>例如，<code>fetch(&#39;http://website-b.com&#39;)</code> 不会发送任何 cookie，即使它是属于 <code>website-b.com</code> 域名的 cookie。</p><p>为什么？</p><p>这是因为携带 <em>credentials</em> 的请求比没有携带 <em>credentials</em> 的请求要&quot;强大&quot;得多。如果允许携带 <em>credentials</em>，这相当于授予 JavaScript 用户的权限，并可以使用他们的 <em>credentials</em> 访问敏感信息。</p><p>服务器真的这么信任这个脚本吗？所以，它必须附加一个头信息以明确地指明是否允许带有 <em>credentials</em> 的请求。</p><p>为了在 fetch 中发送 <em>credentials</em>，我们需要指定 <code>credentials: &#39;include&#39;</code>，像这样：</p><div class="language-js"><pre><code><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;http://website-b.com&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  credentials<span class="token operator">:</span> <span class="token string">&#39;include&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>现在，fetch 将来自 <code>website-b.com</code> 的 cookie 与请求一起发送到该网站。</p><p>如果服务器同意接受带有 <em>credentials</em> 的请求，那么除了 <code> Access-Control-Allow-Credentials: true</code> 之外，它还应该在响应中添加一个 <code>Access-Control-Allow-Origin</code> 头。例如：</p><div class="language-http"><pre><code>200 OK
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> https://website-a.com
<span class="token header-name keyword">Access-Control-Allow-Credentials:</span> true
</code></pre></div><p>请注意：<code>Access-Control-Allow-Origin</code> 禁止对带有 <em>credentials</em> 的请求使用星号 <code>*</code>。就像上面显示的那样，而是必须提供准确的来源。这是一个额外的安全措施，以确保服务器真正知道是谁发起的这个请求。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><ul><li>从浏览器的角度，跨源请求分为两种：安全请求和不安全请求。</li><li>安全请求必须满足两个特定条件： <ul><li>请求方法只能是 GET，POST，HEAD</li><li>只能设置以下请求头 <ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code> 只能是 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code> 之一</li></ul></li></ul></li><li>安全请求和不安全请求的本质区别是：安全的请求可以通过 <code>&lt;form&gt;</code> 或 <code>&lt;script&gt;</code> 标签来实现，这也是早期浏览器发送跨源请求的方式。而不安全的请求在很长一段时间内，浏览器是无法发送的。</li><li>安全请求会被浏览器直接发送： <ul><li>--&gt; 浏览器加上 <code>Origin</code> 头信息，然后发送给服务器</li><li>&lt;-- 对于没有携带 credentials 的请求，服务器设置如下响应头: <ul><li><code>Access-Control-Allow-Origin</code> 为 <code>*</code> 或 与 <code>Origin</code> 相同的值</li></ul></li><li>&lt;-- 对于携带了 credentials 的请求，服务器设置如下响应头： <ul><li><code>Access-Control-Allow-Origin</code> 为与 <code>Origin</code> 相同的值</li><li><code>Access-Control-Allow-Credentials</code> 为 true</li></ul></li></ul></li><li>若要授权 JavaScript 访问除了 <code>Cache-Control</code>, <code>Content-Language</code>, <code>Content-Type</code>, <code>Expires</code>, <code>Last-Modified</code>，<code>Pragma</code> 之外的响应头，服务器应该设置 <code>Access-Control-Expose-Headers</code> 头，并将允许访问的头字段列入其中</li><li>对于不安全请求，浏览器会先发起一个预检请求询问服务器的访问权限： <ul><li>--&gt; 浏览器发送 <code>OPTIONS</code> 请求到相同的请求地址，并携带如下请求头： <ul><li><code>Access-Control-Request-Method</code>：不安全请求方法</li><li><code>Access-Control-Request-Headers</code>：不安全的请求头列表</li></ul></li><li>&lt;-- 服务器响应 200 状态码以及如下响应头： <ul><li><code>Access-Control-Allow-Methods</code>：允许的不安全请求方法列表</li><li><code>Access-Control-Allow-Headers</code>：允许的不安全请求头列表</li><li><code>Access-Control-Max-Age</code>：该权限的缓存时长</li></ul></li><li>然后浏览器发送实际的请求，过程同安全请求一样。</li></ul></li></ul></div></div><footer class="page-footer" data-v-8fcebc32 data-v-5c96fb00><div class="edit" data-v-5c96fb00><div class="edit-link" data-v-5c96fb00 data-v-55695e90><!----></div></div><div class="updated" data-v-5c96fb00><!----></div></footer><div class="next-and-prev-link" data-v-8fcebc32 data-v-e65a9748><div class="container" data-v-e65a9748><div class="prev" data-v-e65a9748><a class="link" href="/yangss/articles/understand-weakmap-and-weakset" data-v-e65a9748><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-e65a9748><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-e65a9748>深入理解 WeakMap 和 WeakSet</span></a></div><div class="next" data-v-e65a9748><a class="link" href="/yangss/articles/async-setup" data-v-e65a9748><span class="text" data-v-e65a9748>异步 setup</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-e65a9748><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"readme.md\":\"415706a0\",\"articles_async-setup.md\":\"20d95dd7\",\"articles_excess-property-checking-in-typescript.md\":\"558c369e\",\"articles_explaining-proxy-and-reflect-in-detail.md\":\"dbd0b8fc\",\"articles_how-context-is-used-in-typescript.md\":\"bc43d58e\",\"articles_index.md\":\"da255f86\",\"articles_settimeout-setinterval.md\":\"251a5307\",\"articles_switch-true-pattern.md\":\"3a94462e\",\"articles_understand-arraybuffer.md\":\"b7dd3054\",\"articles_understand-cors.md\":\"2590d5a3\",\"articles_understand-ts-type-system.md\":\"a4d5fdfd\",\"articles_understand-unknown-in-typescript.md\":\"ceed3393\",\"articles_understand-weakmap-and-weakset.md\":\"ad3eabea\",\"articles_what-is-blob.md\":\"79550dfa\",\"articles_what-is-currying.md\":\"03c96736\",\"articles_what-is-decorator-pattern.md\":\"71d8c1a1\",\"bookmarks.md\":\"57168278\",\"index.md\":\"d0d03762\",\"notes_git.md\":\"1f226f5e\",\"notes_index.md\":\"3f328f92\",\"notes_linux.md\":\"a7fbcfd5\",\"notes_nginx.md\":\"20f9d9cc\",\"notes_package-json.md\":\"7515ba0b\",\"notes_regexp.md\":\"90464ba9\",\"notes_type-challenges.md\":\"b93d6e2d\",\"notes_typescript.md\":\"cfc87439\",\"projects.md\":\"0024e011\"}")</script>
    <script type="module" async src="/yangss/assets/app.04efe956.js"></script>
    
  </body>
</html>